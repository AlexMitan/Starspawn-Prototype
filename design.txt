next: event queueing

Command: [Word*]


Entity
    baseName: str 
    +- parent: ID
    +- rel: str

Word < Entity

Intent
    representation: [Entity*]
    sequence: [Action*]

Actor
    intent: null | Intent

Pattern
    intents() => [Intent*]

Signal
    type: str

Action
    +- actor: id
    +- effect: func*
    +- duration: int
    +- pause: int
    +- condition: func()
    +- signals: [Signal*]

Core
    queue: [Action*]

loop:
    1) getIntent() - hangs for input
        start ready
        for every actor, get intent.
            if duration
                duration--
        if not ready, redo in 100ms
    2) emitSignals() - instant
        start !ready
        while not ready
            set ready
            for every Action, propagate signal
                clear signals of action
                queue extra Actions after emitter and unset "ready"

    3) execute() - instant if waiting on ewcs Action
        while not empty:
            get next Action
                if condition()
                    if effect()
                        do effect
                if waiting, set timeout and run execute()
        run getIntent()

next steps:
    visible object tree
    area movement
        one-way, two-way
            A <---> B
            A ----> B
        access
            A x ???    B
            A x------> B
            A ---x---> B
            A ------x> B
    Bootstrap UI
    log items
    on-mouse-over examine - hold mouse over to charge

fancy:
    D3 transitions
