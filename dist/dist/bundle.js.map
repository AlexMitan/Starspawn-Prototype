{"version":3,"file":"./dist/bundle.js","mappings":";;;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA,aAAa,mBAAO,CAAC,iCAAU;AAC/B,sBAAsB,mBAAO,CAAC,+CAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,6DAA6D,IAAI;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,gCAAgC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,qBAAqB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,gBAAgB;AACvE;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yCAAyC;AACjF;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,iBAAiB,GAAG,gBAAgB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW,cAAc,GAAG;AAC1D,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA,kCAAkC,sCAAsC;AACxE,mEAAmE,gBAAgB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8BAA8B,GAAG,gBAAgB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,kEAAkE,iCAAiC,GAAG,gBAAgB;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,YAAY;AACZ;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,oBAAoB,sBAAsB;AAC1C,qBAAqB,aAAa;AAClC;AACA;AACA;;;;;;;;;;;ACzba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB,4BAA4B,kCAAkC;AAC7G,wDAAwD,4BAA4B;AACpF;AACA;AACA;AACA,+BAA+B,0CAA0C;AACzE;AACA;AACA;AACA;AACA,sDAAsD,uBAAuB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAwC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,0DAA0D,GAAG,gBAAgB;AACzI;AACA,0BAA0B,uCAAuC;AACjE;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oBAAoB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA,CAAC;AACD,cAAc;;;;;;;;;;;AC5LD;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,2BAA2B;AAChF;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA,CAAC;AACD,qBAAqB;;;;;;;;;;;ACtBR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,iCAAU;AAC/B;AACA,qDAAqD,kBAAkB;AACvE;AACA,+CAA+C,MAAM;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sEAAsE,iDAAiD,GAAG,gBAAgB;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAA8C;AACxE;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,qBAAqB,4BAA4B;AACjD,qBAAqB,6BAA6B;AAClD,qBAAqB,6BAA6B;AAClD,wBAAwB,+BAA+B;AACvD,qBAAqB,wCAAwC;AAC7D,qBAAqB,sCAAsC;AAC3D,qBAAqB,sCAAsC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,sEAAsE,iBAAiB,GAAG,gBAAgB;AAC1G;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,eAAe;AACf,mBAAmB;;;;;;;;;;;AClON;AACb;AACA,kDAAkD,QAAQ;AAC1D,yCAAyC,QAAQ;AACjD,yDAAyD,QAAQ;AACjE;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,iCAAU;AAC/B;AACA,qDAAqD,kBAAkB;AACvE;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,+CAA+C,MAAM;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4BAA4B;AAC9C,kBAAkB,6BAA6B;AAC/C,kBAAkB,6BAA6B;AAC/C,kBAAkB,+BAA+B;AACjD,kBAAkB,+BAA+B;AACjD;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,uBAAuB,GAAG,gBAAgB;AAChH;AACA,0EAA0E,0CAA0C,GAAG,gBAAgB;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,iEAAiE,gBAAgB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,8DAA8D,GAAG,gBAAgB;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,kFAAkF,gBAAgB;AAClG;AACA,8EAA8E,gBAAgB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,wCAAwC,GAAG,gBAAgB;AACjI;AACA,0EAA0E,mBAAmB,GAAG,gBAAgB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,sEAAsE,6CAA6C,GAAG,gBAAgB;AACtI;AACA,0EAA0E,0BAA0B,GAAG,gBAAgB;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,sDAAsD,GAAG,gBAAgB;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,sEAAsE,qDAAqD,GAAG,gBAAgB;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,0CAA0C,GAAG,gBAAgB;AACnI;AACA,iCAAiC,SAAS;AAC1C,wCAAwC,SAAS;AACjD,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,sEAAsE,oBAAoB,GAAG,gBAAgB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,0CAA0C,GAAG,gBAAgB;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sEAAsE,sBAAsB,GAAG,gBAAgB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,gFAAgF,iBAAiB,GAAG,gBAAgB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sEAAsE,sBAAsB,GAAG,gBAAgB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uCAAuC;AACjE;AACA,0BAA0B,4CAA4C;AACtE;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,0BAA0B;AACnF;AACA;AACA;AACA;AACA,yBAAyB,GAAG,gBAAgB;AAC5C;AACA;AACA,6DAA6D,gBAAgB,SAAS,0BAA0B;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,GAAG,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,sEAAsE,gCAAgC,GAAG,gBAAgB;AACzH;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAG,gBAAgB;AACpC;AACA;AACA;AACA;AACA,8EAA8E,yDAAyD,GAAG,gBAAgB;AAC1J;AACA;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,0BAA0B,GAAG,gBAAgB;AACnH;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD,KAAK;AACL;AACA;AACA,4DAA4D,4BAA4B;AACxF;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B,KAAK;AACL,mDAAmD,iCAAiC;AACpF,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC,KAAK;AACL;AACA,eAAe;AACf,mBAAmB;;;;;;;;;;;AC3sBN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;;;;;;;UCjBT;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,yCAAc;AACvC,mBAAmB,mBAAO,CAAC,6CAAgB;AAC3C,iBAAiB,mBAAO,CAAC,yCAAc;AACvC,eAAe,mBAAO,CAAC,qCAAY;AACnC;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB,KAAK,KAAK;AAC1D;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,cAAc,uCAAuC;AACrD;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA","sources":["webpack://starspawn/./src/GameModule.ts","webpack://starspawn/./src/PlayerModule.ts","webpack://starspawn/./src/PriorityQueue.ts","webpack://starspawn/./src/modDebug.ts","webpack://starspawn/./src/modTeaRoom.ts","webpack://starspawn/./src/timing.ts","webpack://starspawn/webpack/bootstrap","webpack://starspawn/./src/index.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// let utils = require(\"./utils\")\n// let timing = require(\"./timing\");\nvar timing = require(\"./timing\");\nvar PriorityQueue_1 = require(\"./PriorityQueue\");\nvar Game = /** @class */ (function () {\n    function Game() {\n        this.id = 0;\n        this.entities = [];\n        this.words = {};\n        this.actionId = 0;\n        this.history = [];\n        this.log = [];\n        this.intentsReady = true;\n        this.queue = []; // [Action*]\n        this.queueSpliceI = 0;\n        this.handlers = new PriorityQueue_1.PriorityQueue(); // {on_eventType:func()}\n        this.time = 0;\n        this.player = null;\n        this.playRandomly = false;\n        this.actions = {};\n    }\n    Game.prototype.addEntity = function (entity, parentEntity, rel) {\n        if (parentEntity === void 0) { parentEntity = null; }\n        if (rel === void 0) { rel = null; }\n        this.entities.push(entity);\n        entity.id = this.id;\n        this.id += 1;\n        if (parentEntity !== null) {\n            this.setParent(parentEntity, entity, rel);\n        }\n        return entity;\n    };\n    Game.prototype.getById = function (id) {\n        var found = undefined;\n        for (var i = 0; i < this.entities.length; i++) {\n            if (this.entities[i].id === id) {\n                found = this.entities[i];\n            }\n        }\n        if (found === undefined)\n            throw \"object not found with id \" + id;\n        return found;\n    };\n    Game.prototype.getDepth = function (entity) {\n        var depth = 0;\n        while (this.getParent(entity) !== undefined) {\n            entity = this.getParent(entity);\n            depth += 1;\n        }\n        return depth;\n    };\n    Game.prototype.addHandler = function (value, handler) {\n        this.handlers.enqueue({ value: value, element: handler });\n        return handler;\n    };\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // PARENT\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    Game.prototype.setParent = function (parentEntity, childEntity, rel) {\n        if (rel === void 0) { rel = null; }\n        if (parentEntity === undefined ||\n            parentEntity.id === undefined ||\n            this.getById(parentEntity.id) === undefined)\n            throw \"Undefined parent.\";\n        this.unsetParent(childEntity);\n        childEntity.parent = parentEntity.id;\n        if (rel !== null) {\n            childEntity.rel = rel;\n        }\n    };\n    Game.prototype.setParentById = function (parentId, childId, rel) {\n        if (rel === void 0) { rel = null; }\n        this.setParent(this.getById(parentId), this.getById(childId), rel);\n    };\n    Game.prototype.unsetParent = function (childEntity) {\n        childEntity.parent = undefined;\n    };\n    Game.prototype.isParent = function (parentEntity, childEntity) {\n        return parentEntity.id === childEntity.parent;\n    };\n    Game.prototype.getParent = function (childEntity) {\n        var parent = childEntity.parent === undefined\n            ? undefined\n            : this.getById(childEntity.parent);\n        return parent;\n    };\n    Game.prototype.getChildren = function (entity) {\n        // console.log(\"loop\", entity.id);\n        var contents = this.entities.filter(function (e) { return e.parent === entity.id; });\n        // let contents = this.entities.filter((e) => this.isParent(entity, e));\n        return contents;\n    };\n    Game.prototype.getChildrenById = function (id) {\n        return this.getChildren(this.getById(id));\n    };\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    Game.prototype.deleteById = function (id) {\n        // TODO? throw if not found\n        this.entities = this.entities.filter(function (e) { return e.id !== id; });\n    };\n    Game.prototype.isAccessible = function (entity) {\n        if (entity === undefined || this.getParent(entity) === undefined)\n            return true;\n        var parent = this.getParent(entity);\n        var accessible = (parent.closed === false || parent.closed === undefined) &&\n            (parent.locked === undefined || parent.locked.isLocked === false);\n        return accessible && this.isAccessible(parent);\n    };\n    Game.prototype.enqueue = function (action, splice) {\n        if (splice === void 0) { splice = true; }\n        if (!splice) {\n            this.queue.push(action);\n        }\n        else {\n            this.queue.splice(this.queueSpliceI, 0, action);\n            this.queueSpliceI++;\n        }\n    };\n    Game.prototype.emitEvent = function (data) {\n        for (var _i = 0, _a = this.handlers.asArray(); _i < _a.length; _i++) {\n            var handler = _a[_i];\n            if (handler[\"on_\" + data.type]) {\n                console.log({ data: data });\n                handler[\"on_\" + data.type](data);\n            }\n        }\n    };\n    Game.prototype.queueEvent = function (data) {\n        this.enqueue({ events: [data] });\n    };\n    // called when action is first started\n    Game.prototype.processAction = function (action) {\n        if (action.maxDuration === undefined) {\n            action.maxDuration = action.duration || 0;\n            this.actionId += 1;\n            action.id = this.actionId;\n            var logItem = {\n                id: action.id,\n            };\n            this.history.push(action);\n            this.log.push(logItem);\n        }\n        return action;\n    };\n    Game.prototype.updateLog = function () {\n        for (var i_1 = 0; i_1 < this.log.length; i_1++) {\n            var logItem = this.log[i_1];\n            var logId = logItem.id;\n            for (var hc = 0; hc < this.history.length; hc++) {\n                var action = this.history[hc];\n                var actionId = action.id;\n                // match log item to action\n                if (logId === actionId) {\n                    if (action.duration && action.duration >= 0) {\n                        logItem.progressBar = \"[\" + (\"=\".repeat(action.maxDuration - action.duration) +\n                            \"-\".repeat(action.duration)) + \"]\";\n                        logItem.sticky = true;\n                    }\n                    else {\n                        if (action.maxDuration > 0) {\n                            logItem.progressBar = \"[\" + \"=\".repeat(action.maxDuration) + \"]\";\n                        }\n                        logItem.sticky = false;\n                    }\n                }\n            }\n        }\n        this.log.sort(function (a, b) { return (a.sticky && !b.sticky ? 1 : 0); });\n        // update UI\n        var display = document.getElementById(\"display\");\n        display.innerText = \"\";\n        var i = Math.max(0, this.log.length - 50);\n        for (var _i = 0, _a = this.log.slice(i); _i < _a.length; _i++) {\n            var logItem = _a[_i];\n            if (logItem.text) {\n                display.innerText += \"\\n\" + logItem.text;\n            }\n            if (logItem.progressBar) {\n                display.innerText += \"\\n\" + logItem.progressBar;\n            }\n        }\n        display.scrollTop = display.scrollHeight;\n        console.log(this.log);\n    };\n    Game.prototype.newLine = function (text) {\n        this.actionId += 1;\n        var logItem = {\n            text: \"\" + text,\n            id: this.actionId,\n        };\n        this.log.push(logItem);\n    };\n    Game.prototype.getIntents = function () {\n        var _this = this;\n        // get this tick's Actions {aedpcs} for every entity with intent (null or Intent)\n        this.intentsReady = true;\n        var _loop_1 = function (entity) {\n            var intent = entity.actor.intent;\n            // empty intent\n            if (!intent) {\n                this_1.intentsReady = false;\n                // hang and reset for player input\n                if (entity.player) {\n                    if (!entity.picking) {\n                        entity.picking = true;\n                        entity.setOptionsUI();\n                    }\n                    setTimeout(function () {\n                        var options = entity.getNextWords();\n                        if (_this.playRandomly) {\n                            if (entity.command.length > 0) {\n                                entity.pickNextWord(Math.floor(Math.random() * (options.length - 1)));\n                            }\n                            else {\n                                entity.pickNextWord(Math.floor(Math.random() * options.length));\n                            }\n                        }\n                        _this.getIntents();\n                    }, 100);\n                }\n            }\n            else if (intent && intent.sequence.length > 0) {\n                // extract actions and enqueue them\n                var ticks = 0;\n                // extract actions until we go over 1 tick\n                while (ticks === 0 && intent.sequence.length > 0) {\n                    // process and enqueue action\n                    intent.sequence[0] = this_1.processAction(intent.sequence[0]);\n                    var action = intent.sequence[0];\n                    this_1.enqueue(action, false);\n                    // queue up actions including the first with duration\n                    if (action.duration <= 0 || action.duration === undefined) {\n                        // instant action, keep queueSpliceIng\n                        intent.sequence.splice(0, 1);\n                    }\n                    else if (action.duration > 0) {\n                        // action that will be taken multiple times\n                        ticks = action.duration;\n                        // end actions here\n                        if (action.duration <= 1) {\n                            intent.sequence.splice(0, 1);\n                        }\n                        action.duration -= 1;\n                    }\n                    else {\n                        // throw `Not sure what this means`;\n                    }\n                }\n                // if the last action was extracted, render null\n                if (intent.sequence.length === 0) {\n                    entity.actor.intent = null;\n                }\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, _a = this.entities.filter(function (e) { return e.actor; }); _i < _a.length; _i++) {\n            var entity = _a[_i];\n            _loop_1(entity);\n        }\n        // when ready, propagate events\n        if (this.intentsReady) {\n            // queue up a tick event\n            this.queue.push({ events: [{ type: \"tick\" }] });\n            // newLine(`starting tick ${game.time}`);\n            this.processNext();\n        }\n    };\n    Game.prototype.processNext = function () {\n        var _this = this;\n        // get next action to execute\n        if (this.queue.length > 0) {\n            this.queueSpliceI = 0;\n            var action = this.queue.shift();\n            // func: execute command\n            if (action.func) {\n                if (this.actions[action.func]) {\n                    var func = this.actions[action.func];\n                    if (action.args) {\n                        func.apply(void 0, action.args);\n                    }\n                    else {\n                        func();\n                    }\n                }\n                else {\n                    throw \"Unknown action \" + action.func + \", args \" + action.args;\n                }\n            }\n            // events: propagate events\n            if (action.events && action.events.length > 0) {\n                for (var _i = 0, _a = action.events; _i < _a.length; _i++) {\n                    var event_1 = _a[_i];\n                    // new event to propagate\n                    var type = event_1.type;\n                    // send to every handler\n                    var responses = [];\n                    console.log({ event: event_1, i: this.queueSpliceI });\n                    for (var _b = 0, _c = this.handlers.asArray(); _b < _c.length; _b++) {\n                        var handler = _c[_b];\n                        if (handler[\"on_\" + type]) {\n                            handler[\"on_\" + type](event_1);\n                        }\n                    }\n                }\n            }\n            // pause: execute the next instantly or with pause\n            this.updateUI();\n            if (action.pause) {\n                setTimeout(function () {\n                    _this.processNext();\n                }, action.pause);\n            }\n            else {\n                this.processNext();\n            }\n        }\n        else {\n            // loop again\n            this.time += 1;\n            this.getIntents();\n        }\n    };\n    Game.prototype.word = function (text) {\n        if (!this.words[text]) {\n            var word = { type: \"word\", baseName: text };\n            this.words[text] = word;\n        }\n        return this.words[text];\n    };\n    Game.prototype.updateUI = function () {\n        this.updateEntityTreeUI();\n        this.updateClockUI();\n        this.updateLog();\n    };\n    Game.prototype.updateEntityTreeUI = function () {\n        var _this = this;\n        // time\n        var ticks = this.time % timing.tps;\n        var hours = Math.floor(this.time / timing.tps / 3600);\n        var minutes = Math.floor(this.time / timing.tps / 60);\n        var seconds = Math.floor(this.time / timing.tps);\n        var game = this;\n        var treeNode = document.getElementById(\"entityTree\");\n        treeNode.innerHTML = \"Time: \" + hours + \":\" + minutes + \":\" + seconds + \":\" + ticks + \"\\n\\n</br>\";\n        // subtree\n        function indentedSubtree(entity, depth) {\n            if (depth === void 0) { depth = 0; }\n            if (!entity.baseName || entity.invisible)\n                return null;\n            var healthText = entity.health > 0 ? \"[\" + \"#\".repeat(entity.health) + \"]\" : \"\";\n            var focusedText = game.player.focus === entity.id ? \"(focused)\" : \"\";\n            var textNode = document.createElement(\"a\");\n            // textNode.style.color = \"lightgrey\";\n            textNode.innerText = \"|\" + \"----\".repeat(depth) + entity.baseName + \" \" + healthText + focusedText + \"\\n\";\n            textNode.className = \"treeObject\";\n            if (game.getChildren(entity).length > 0) {\n                for (var _i = 0, _a = game\n                    .getChildren(entity)\n                    .filter(function (e) { return game.isAccessible(e); }); _i < _a.length; _i++) {\n                    var child = _a[_i];\n                    var subtree = indentedSubtree(child, depth + 1);\n                    if (subtree !== null)\n                        textNode.appendChild(subtree);\n                }\n            }\n            // on click, focus action\n            textNode.addEventListener(\"click\", function (e) {\n                e = window.event || e;\n                if (this === e.target) {\n                    game.player.focus = entity.id;\n                    game.player.command = [];\n                    game.player.setOptionsUI();\n                }\n                game.updateEntityTreeUI();\n            });\n            return textNode;\n        }\n        for (var _i = 0, _a = this.entities.filter(function (e) { return _this.getDepth(e) === 0; }); _i < _a.length; _i++) {\n            var entity = _a[_i];\n            var subtree = indentedSubtree(entity, 0);\n            if (subtree) {\n                treeNode.appendChild(subtree);\n            }\n        }\n    };\n    Game.prototype.updateClockUI = function () {\n        var clock = document.getElementById(\"clock\");\n        var ctx = clock.getContext(\"2d\");\n        var width = clock.clientWidth;\n        var height = clock.clientHeight;\n        // ctx.stroke = \"white\";\n        ctx.clearRect(0, 0, width, height);\n        ctx.fillText(\"\" + this.time, width / 2 - 6, height / 2 + 5);\n        // dots\n        ctx.save();\n        ctx.translate(width / 2, height / 2);\n        ctx.beginPath();\n        ctx.rotate(-Math.PI / 2);\n        for (var i = 0; i < 12; i++) {\n            ctx.moveTo(20, 0);\n            ctx.lineTo(25, 0);\n            ctx.rotate((2 * Math.PI) / 12);\n        }\n        ctx.stroke();\n        ctx.restore();\n        // ticks\n        ctx.save();\n        ctx.translate(width / 2, height / 2);\n        ctx.beginPath();\n        ctx.rotate(-Math.PI / 2);\n        ctx.rotate((2 * Math.PI * this.time) / timing.tps);\n        ctx.arc(10, 0, 2, 0, 2 * Math.PI);\n        ctx.stroke();\n        ctx.restore();\n        // seconds\n        // ticks\n        ctx.save();\n        ctx.translate(width / 2, height / 2);\n        ctx.beginPath();\n        ctx.rotate(-Math.PI / 2);\n        ctx.rotate((2 * Math.PI * this.time) / timing.tps / 60);\n        ctx.moveTo(10, 0);\n        ctx.lineTo(25, 0);\n        ctx.stroke();\n        ctx.restore();\n    };\n    return Game;\n}());\nexports.Game = Game;\n// let g = new Game();\n// let teapot = g.buildObject(\n//     {\n//         teapot: true,\n//     },\n//     [\n//         [\"is\", { fluidContainer: true }],\n//         [\"has\", { spout: true }],\n//     ]\n// );\n// console.log(g.entities);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Player = /** @class */ (function () {\n    function Player() {\n        this.parent = undefined;\n        this.baseName = \"player\";\n        this.player = true;\n        this.actor = {\n            intent: null,\n        };\n        this.picking = false;\n        this.command = [];\n        this.patterns = [];\n        this.focus = null;\n        this.id = -1;\n    }\n    Player.prototype.addPattern = function (pattern) {\n        this.patterns.push(pattern);\n    };\n    Player.prototype.getAllIntents = function () {\n        var intents = [];\n        for (var _i = 0, _a = this.patterns; _i < _a.length; _i++) {\n            var pattern = _a[_i];\n            for (var _b = 0, _c = pattern.intents(); _b < _c.length; _b++) {\n                var intent = _c[_b];\n                intents.push(intent);\n            }\n        }\n        return intents;\n    };\n    //^ getAllIntents(), command\n    Player.prototype.getValidIntents = function () {\n        // get remaining Intents that match the command and focus so far\n        var validIntents = [];\n        for (var _i = 0, _a = this.getAllIntents(); _i < _a.length; _i++) {\n            var intent = _a[_i];\n            // check intent for command validity\n            var cmdValid = true;\n            for (var i = 0; i < this.command.length; i++) {\n                if (intent.representation[i] !== this.command[i]) {\n                    cmdValid = false;\n                }\n            }\n            // check intent for focus validity, if any focus\n            var focusValid = this.focus ? false : true;\n            for (var _b = 0, _c = intent.representation; _b < _c.length; _b++) {\n                var entity = _c[_b];\n                if (entity.id === this.focus) {\n                    focusValid = true;\n                }\n            }\n            if (cmdValid && focusValid) {\n                validIntents.push(intent);\n            }\n        }\n        return validIntents;\n    };\n    //^ getValidIntents(), command\n    // get options for next word to pick\n    Player.prototype.getNextWords = function () {\n        var options = [];\n        var validIntents = this.getValidIntents();\n        // console.log(`${validIntents.length} valid commands at command ${this.command.map(w => w.baseName)}`)\n        for (var _i = 0, validIntents_1 = validIntents; _i < validIntents_1.length; _i++) {\n            var intent = validIntents_1[_i];\n            // if the intent is the same length as the command, it can be confirmed\n            if (intent.representation.length == this.command.length) {\n                options.push({ baseName: \"> confirm <\", type: \"confirm\" });\n            }\n            else {\n                var newOption = intent.representation[this.command.length];\n                var duplicateThing = false;\n                for (var _a = 0, options_1 = options; _a < options_1.length; _a++) {\n                    var option = options_1[_a];\n                    if (newOption === option) {\n                        duplicateThing = true;\n                    }\n                }\n                if (!duplicateThing) {\n                    options.push(newOption);\n                }\n            }\n        }\n        if (this.command.length > 0) {\n            options.push({ baseName: \"> cancel <\", type: \"cancel\" });\n        }\n        return options;\n    };\n    //^ updateCommandUI()\n    Player.prototype.pickNextWord = function (optionI) {\n        var options = this.getNextWords();\n        if (options[optionI].type === \"confirm\") {\n            this.setIntent();\n        }\n        else if (options[optionI].type === \"cancel\") {\n            this.command = [];\n            this.focus = null;\n        }\n        else {\n            this.command.push(options[optionI]);\n        }\n        this.updateCommandUI();\n    };\n    // getValidIntents(), clearCommand()\n    // set intent and clear the command\n    Player.prototype.setIntent = function () {\n        var _this = this;\n        // get valid intents\n        var intents = this.getValidIntents();\n        // from intents of command's length\n        for (var _i = 0, _a = intents.filter(function (i) { return i.representation.length === _this.command.length; }); _i < _a.length; _i++) {\n            var intent = _a[_i];\n            console.log({ intent: intent, command: this.command });\n            var valid = true;\n            for (var i = 0; i < intent.representation.length; i++) {\n                if (intent.representation[i] !== this.command[i]) {\n                    console.log(\"execution wonk, not one valid action\");\n                    valid = false;\n                }\n            }\n            if (valid) {\n                // set intent, not picking\n                this.actor.intent = intent;\n                // intent.totalDuration = intent.sequence.reduce(\n                //     (sum, action) => sum + action.duration || 0,\n                //     0\n                // );\n                // intent.elapsed = 0;\n                // console.log({ intent });\n                this.picking = false;\n                this.focus = null;\n                // clear command\n                this.command = [];\n                this.updateCommandUI();\n                return;\n            }\n        }\n    };\n    Player.prototype.updateCommandUI = function () {\n        document.getElementById(\"command\").innerHTML =\n            \">\" + this.command.map(function (e) { return e.baseName; }).join(\" \");\n    };\n    Player.prototype.clearOptionsUI = function () {\n        document.getElementById(\"options\").innerHTML = \"\";\n    };\n    Player.prototype.setOptionsUI = function () {\n        var _this = this;\n        document.getElementById(\"options\").innerHTML = \"\";\n        if (!this.picking)\n            return;\n        // get the next words, and create an element for each on document\n        var options = this.getNextWords();\n        var keys = \"abcdefghijklmnopqrstuwxyz\".split(\"\");\n        var _loop_1 = function (i) {\n            var optionText = options[i].baseName;\n            // create a span with the optionText baseName\n            shortcutNode = document.createElement(\"a\");\n            // shortcutNode.style.color = \"lightgrey\";\n            shortcutNode.innerText = keys[i] + \") \";\n            // keyboard shortcutNode\n            optionNode = document.createElement(\"a\");\n            // optionNode.style.color = \"white\";\n            optionNode.innerText = optionText;\n            shortcutNode.appendChild(optionNode);\n            document.getElementById(\"options\").appendChild(shortcutNode);\n            // when the span is clicked, handle using that optionText\n            // REFACTOR: bad\n            shortcutNode.addEventListener(\"click\", function () {\n                _this.pickNextWord(i);\n                _this.setOptionsUI();\n            });\n            if (options[i].type === \"confirm\") {\n                shortcutNode.className = \"confirm\";\n            }\n            else if (options[i].type === \"cancel\") {\n                shortcutNode.className = \"cancel\";\n            }\n            else {\n                shortcutNode.className = \"choice\";\n            }\n        };\n        var shortcutNode, optionNode;\n        for (var i = 0; i < options.length; i++) {\n            _loop_1(i);\n        }\n    };\n    return Player;\n}());\nexports.Player = Player;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PriorityQueue = /** @class */ (function () {\n    function PriorityQueue() {\n        this.list = [];\n    }\n    PriorityQueue.prototype.enqueue = function (element) {\n        this.list.push(element);\n        this.reorganise();\n        return element;\n    };\n    PriorityQueue.prototype.reorganise = function () {\n        this.list = this.list.sort(function (a, b) { return a.value - b.value; });\n    };\n    PriorityQueue.prototype.getAt = function (i) {\n        return this.list[i].element;\n    };\n    PriorityQueue.prototype.asArray = function () {\n        return this.list.map(function (pqe) { return pqe.element; });\n    };\n    return PriorityQueue;\n}());\nexports.PriorityQueue = PriorityQueue;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar timing = require(\"./timing\");\nfunction loadMod(game) {\n    var player = game.entities.filter(function (e) { return e.player; })[0];\n    game.actions.wait = function (ticks) {\n        // game.newLine(`Still waiting... of ${ticks}`);\n    };\n    function createNewLineAction(text) {\n        return {\n            func: \"newLine\",\n            args: [text],\n        };\n    }\n    function createWaitAction(ticks) {\n        return {\n            func: \"wait\",\n            args: [ticks],\n            duration: ticks,\n            // 1 -> 1, 10 -> 2\n            pause: timing.mpt / Math.pow(ticks, 1),\n        };\n    }\n    game.actions.traverse = function (actorId, pathId) {\n        var path = game.getById(pathId);\n        var origin = game.getById(path.path.from);\n        var destination = game.getById(path.path.to);\n        var actor = game.getById(actorId);\n        if (actor.player) {\n            game.newLine(\"You go to \" + destination.baseName);\n        }\n        game.queueEvent({\n            type: \"traverse\",\n        });\n        actor.parent = destination.id;\n    };\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.path && e.path.from === player.parent; }); _i < _a.length; _i++) {\n                var path = _a[_i];\n                intents.push({\n                    representation: [\n                        game.word(\"go:\"),\n                        game.getById(path.path.to),\n                    ],\n                    sequence: [\n                        createWaitAction(path.path.distance),\n                        { func: \"traverse\", args: [player.id, path.id] },\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    // // wait various durations\n    // player.patterns.push({\n    //     intents: () => {\n    //         let intents = [];\n    //         let durations = [\n    //             { baseName: \"1 tick\", dur: 1 },\n    //             { baseName: \"3 ticks\", dur: 3 },\n    //             { baseName: \"6 ticks\", dur: 6 },\n    //             // { baseName: \"12 ticks\", dur: 12 },\n    //             { baseName: \"1 minute\", dur: timing.m(1) },\n    //             { baseName: \"1 hour\", dur: timing.h(1) },\n    //             { baseName: \"1 day\", dur: timing.h(24) },\n    //         ];\n    //         for (let duration of durations) {\n    //             let intent = {\n    //                 representation: [\n    //                     game.word(\"wait\"),\n    //                     game.word(duration.baseName),\n    //                 ],\n    //                 sequence: [\n    //                     createNewLineAction(`You wait ${duration.dur} ticks.`),\n    //                     createWaitAction(duration.dur),\n    //                 ],\n    //             };\n    //             intents.push(intent);\n    //         }\n    //         return intents;\n    //     },\n    // });\n    // random clapping\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            // the effect function\n            function effect() {\n                game.newLine(\"CLAP!\");\n            }\n            // the sequence\n            intents.push({\n                representation: [game.word(\"DEBUG\"), game.word(\"slow clap.\")],\n                sequence: [\n                    createWaitAction(4),\n                    createNewLineAction(\"CLAP!\"),\n                    createWaitAction(2),\n                    createNewLineAction(\"CLAP!\"),\n                    createNewLineAction(\"CLAP!\"),\n                    createWaitAction(2),\n                    createNewLineAction(\"CLAP!\"),\n                    createNewLineAction(\"CLAP!\"),\n                    createNewLineAction(\"CLAP!\"),\n                ],\n            });\n            return intents;\n        },\n    });\n    function createPingAction() {\n        return {\n            func: \"newLine\",\n            args: [\"ping\"],\n            pause: 100,\n            events: [{ type: \"ping\" }],\n            duration: 0,\n        };\n    }\n    // 3x ping, to be responded to with pong and peng\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            intents.push({\n                representation: [game.word(\"DEBUG\"), game.word(\"3 x ping.\")],\n                sequence: [\n                    createPingAction(),\n                    createPingAction(),\n                    createPingAction(),\n                ],\n            });\n            return intents;\n        },\n    });\n    game.addHandler(0, {\n        on_ping: function (data) {\n            game.enqueue({\n                func: \"newLine\",\n                args: [\"Pong!\"],\n                events: [{ type: \"pong\" }],\n                pause: 300,\n            });\n        },\n    });\n    game.addHandler(0, {\n        on_pong: function (data) {\n            game.enqueue({\n                func: \"newLine\",\n                args: [\"Peng!\"],\n                events: [{ type: \"peng\" }],\n                pause: 300,\n            });\n        },\n    });\n    // plain longer action\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            // the sequence\n            intents.push({\n                representation: [\n                    game.word(\"DEBUG\"),\n                    game.word(\"POW\"),\n                    game.word(\"POW\"),\n                    game.word(\"POW\"),\n                ],\n                sequence: [createNewLineAction(\"POW POW POW!\")],\n            });\n            return intents;\n        },\n    });\n    // plain shorter action\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            // the sequence\n            intents.push({\n                representation: [game.word(\"DEBUG\"), game.word(\"POW\")],\n                sequence: [createNewLineAction(\"POW!\")],\n            });\n            return intents;\n        },\n    });\n    // duration 2 action that releases pings\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            // the sequence\n            intents.push({\n                representation: [game.word(\"DEBUG\"), game.word(\"long-ping\")],\n                sequence: [\n                    {\n                        func: \"newLine\",\n                        args: [\"piiiiiiiiing!\"],\n                        pause: 300,\n                        events: [{ type: \"ping\" }],\n                        duration: 2,\n                    },\n                ],\n            });\n            return intents;\n        },\n    });\n    // 3 ticks\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            // the sequence\n            intents.push({\n                representation: [game.word(\"DEBUG\"), game.word(\"wait 3 ticks\")],\n                sequence: [createWaitAction(3)],\n            });\n            return intents;\n        },\n    });\n    // tick timers up\n    game.addHandler(0, {\n        on_tick: function (data) {\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.timer; }); _i < _a.length; _i++) {\n                var timer = _a[_i];\n                timer.timer.time += 1;\n            }\n        },\n    });\n}\nexports.loadMod = loadMod;\nmodule.exports = { loadMod: loadMod };\n","\"use strict\";\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar timing = require(\"./timing\");\nfunction loadMod(game) {\n    var player = game.entities.filter(function (e) { return e.player; })[0];\n    game.actions.newLine = function () {\n        var _a;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return (_a = game.newLine).call.apply(_a, __spreadArrays([game], args));\n    };\n    // let newLine = game.newLine;\n    game.actions.wait = function (ticks) {\n        if (ticks === void 0) { ticks = 0; }\n        // game.newLine(`Still waiting... of ${ticks}`);\n    };\n    function createNewLineAction(text) {\n        return {\n            func: \"newLine\",\n            args: [text],\n        };\n    }\n    function createWaitAction(ticks, processText) {\n        if (processText === void 0) { processText = \"Waiting...\"; }\n        return {\n            func: \"wait\",\n            args: [ticks],\n            duration: ticks,\n            pause: timing.mpt / Math.pow(ticks, 1),\n            processText: processText,\n        };\n    }\n    // wait various durations\n    player.patterns.push({\n        intents: function () {\n            var intents = [];\n            var durations = [\n                { baseName: \"1 tick\", dur: 1 },\n                { baseName: \"3 ticks\", dur: 3 },\n                { baseName: \"6 ticks\", dur: 6 },\n                { baseName: \"12 ticks\", dur: 12 },\n                { baseName: \"60 ticks\", dur: 60 },\n            ];\n            for (var _i = 0, durations_1 = durations; _i < durations_1.length; _i++) {\n                var duration = durations_1[_i];\n                var intent = {\n                    representation: [\n                        game.word(\"wait\"),\n                        game.word(duration.baseName),\n                    ],\n                    sequence: [\n                        createNewLineAction(\"You wait \" + duration.dur + \" ticks.\"),\n                        createWaitAction(duration.dur),\n                    ],\n                };\n                intents.push(intent);\n            }\n            return intents;\n        },\n    });\n    game.actions.fillFrom = function (fluidSourceId, fluidContainerId) {\n        var fluidSource = game.getById(fluidSourceId);\n        var fluidContainer = game.getById(fluidContainerId);\n        var fluid = game.addEntity({\n            baseName: fluidSource.fluidSource,\n            fluid: true,\n            temperature: 20,\n        }, fluidContainer);\n        game.newLine(\"You fill up the \" + fluidContainer.baseName + \" from the \" + fluidSource.baseName + \" with \" + fluid.baseName);\n    };\n    function fluidsIn(fluidContainer) {\n        var fluidChildren = game\n            .getChildren(fluidContainer)\n            .filter(function (e) { return e.fluid; });\n        return fluidChildren.length > 0;\n    }\n    // fill container from fluidSource\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.fluidSource; }); _i < _a.length; _i++) {\n                var fluidSource = _a[_i];\n                for (var _b = 0, _c = game.entities.filter(function (e) { return e.fluidContainer && !fluidsIn(e); }); _b < _c.length; _b++) {\n                    var nonEmptyFluidContainer = _c[_b];\n                    intents.push({\n                        representation: [\n                            game.word(\"fill\"),\n                            nonEmptyFluidContainer,\n                            game.word(\"from\"),\n                            fluidSource,\n                        ],\n                        sequence: [\n                            createWaitAction(3, \"Filling\"),\n                            {\n                                func: \"fillFrom\",\n                                args: [\n                                    fluidSource.id,\n                                    nonEmptyFluidContainer.id,\n                                ],\n                                duration: 1,\n                            },\n                            createWaitAction(3, \"Recovering\"),\n                        ],\n                    });\n                    // throw \"HALT\"\n                }\n            }\n            return intents;\n        },\n    });\n    game.actions.emptyContainer = function (containerId) {\n        var container = game.getById(containerId);\n        var containerParent = game.getParent(container);\n        game.newLine(\"You empty the \" + container.baseName + \" on the \" + containerParent.baseName + \".\");\n        for (var _i = 0, _a = game.getChildrenById(containerId); _i < _a.length; _i++) {\n            var child = _a[_i];\n            if (child.fluid) {\n                game.deleteById(child.id);\n            }\n            else {\n                game.setParent(containerParent, child);\n            }\n        }\n    };\n    player.addPattern({\n        // empty container\n        intents: function () {\n            var intents = [];\n            // nonempty fluid containers\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.fluidContainer && game.getChildren(e).length !== 0; }); _i < _a.length; _i++) {\n                var nonEmptyFluidContainer = _a[_i];\n                intents.push({\n                    representation: [\n                        game.word(\"empty\"),\n                        nonEmptyFluidContainer,\n                    ],\n                    sequence: [\n                        createWaitAction(1),\n                        {\n                            func: \"emptyContainer\",\n                            args: [nonEmptyFluidContainer.id],\n                        },\n                        createWaitAction(1),\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    game.actions.pourXintoY = function (sourceId, destinationId) {\n        var source = game.getById(sourceId);\n        var destination = game.getById(destinationId);\n        for (var _i = 0, _a = game.getChildren(source); _i < _a.length; _i++) {\n            var child = _a[_i];\n            game.newLine(\"You pour the \" + child.baseName + \" from the \" + source.baseName + \" into the \" + destination.baseName + \".\");\n            game.setParent(destination, child);\n        }\n    };\n    player.addPattern({\n        // pour X into Y\n        intents: function () {\n            var intents = [];\n            var isNonEmptyFluidContainer = function (e) {\n                return e.fluidContainer && game.getChildren(e).length !== 0;\n            };\n            var isEmptyContainer = function (e) { return e.fluidContainer && !fluidsIn(e); };\n            for (var _i = 0, _a = game.entities.filter(isNonEmptyFluidContainer); _i < _a.length; _i++) {\n                var sourceContainer = _a[_i];\n                for (var _b = 0, _c = game.entities.filter(isEmptyContainer); _b < _c.length; _b++) {\n                    var destinationContainer = _c[_b];\n                    intents.push({\n                        representation: [\n                            game.word(\"pour\"),\n                            sourceContainer,\n                            game.word(\"into\"),\n                            destinationContainer,\n                        ],\n                        sequence: [\n                            {\n                                func: \"pourXintoY\",\n                                args: [\n                                    sourceContainer.id,\n                                    destinationContainer.id,\n                                ],\n                            },\n                        ],\n                    });\n                }\n            }\n            return intents;\n        },\n    });\n    game.actions.setParentById = function (parentId, childId, rel) {\n        return game.setParentById(parentId, childId, rel);\n    };\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.item && game.isAccessible(e); }); _i < _a.length; _i++) {\n                var entity = _a[_i];\n                for (var _b = 0, _c = game.entities.filter(function (e) { return e.surface; }); _b < _c.length; _b++) {\n                    var surface = _c[_b];\n                    intents.push({\n                        representation: [\n                            game.word(\"put\"),\n                            entity,\n                            game.word(\"on\"),\n                            surface,\n                        ],\n                        sequence: [\n                            createNewLineAction(\"You put the \" + entity.baseName + \" on the \" + surface.baseName),\n                            {\n                                func: \"setParentById\",\n                                args: [surface.id, entity.id, \"on\"],\n                            },\n                        ],\n                    });\n                }\n            }\n            return intents;\n        },\n    });\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.infusable && game.isAccessible(e); }); _i < _a.length; _i++) {\n                var infusable = _a[_i];\n                for (var _b = 0, _c = game.entities.filter(function (e) { return e.fluidContainer; }); _b < _c.length; _b++) {\n                    var fluidContainer = _c[_b];\n                    intents.push({\n                        representation: [\n                            game.word(\"put\"),\n                            infusable,\n                            game.word(\"in\"),\n                            fluidContainer,\n                        ],\n                        sequence: [\n                            {\n                                func: \"setParentById\",\n                                args: [fluidContainer.id, infusable.id, \"in\"],\n                            },\n                            createWaitAction(3),\n                        ],\n                    });\n                }\n            }\n            return intents;\n        },\n    });\n    game.actions.switchActive = function (switchableId) {\n        var switchable = game.getById(switchableId);\n        switchable.active = !switchable.active;\n    };\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.active !== undefined && e.active === false; }); _i < _a.length; _i++) {\n                var entity = _a[_i];\n                intents.push({\n                    representation: [game.word(\"turn on\"), entity],\n                    sequence: [\n                        createNewLineAction(\"You turn on the \" + entity.baseName),\n                        {\n                            func: \"switchActive\",\n                            args: [entity.id],\n                        },\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.active !== undefined && e.active === true; }); _i < _a.length; _i++) {\n                var entity = _a[_i];\n                intents.push({\n                    representation: [game.word(\"turn off\"), entity],\n                    sequence: [\n                        createNewLineAction(\"You turn off the \" + entity.baseName),\n                        {\n                            func: \"switchActive\",\n                            args: [entity.id],\n                        },\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    game.actions.tryUnlock = function (chestId, trialPassword) {\n        var chest = game.getById(chestId);\n        if (trialPassword === chest.locked.password) {\n            chest.locked.isLocked = false;\n            game.newLine(\"The locks click open.\");\n        }\n        else {\n            game.newLine(\"Incorrect password.\");\n        }\n    };\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.locked && game.isAccessible(e); }); _i < _a.length; _i++) {\n                var chest = _a[_i];\n                for (var i0 = 0; i0 < 10; i0++) {\n                    // for (let i1 = 0; i1 < 10; i1++) {\n                    // for (let i2 = 0; i2 < 10; i2++) {\n                    // the sequence\n                    intents.push({\n                        representation: [\n                            game.word(\"unlock\"),\n                            chest,\n                            game.word(String(i0)),\n                        ],\n                        // representation: [game.word(`unlock`), chest, game.word(String(i0)), game.word(String(i1)), game.word(String(i2))],\n                        sequence: [\n                            {\n                                func: \"tryUnlock\",\n                                args: [chest.id, \"\" + i0],\n                            },\n                        ],\n                    });\n                    // }\n                    // }\n                }\n            }\n            return intents;\n        },\n    });\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.readable; }); _i < _a.length; _i++) {\n                var entity = _a[_i];\n                // the sequence\n                intents.push({\n                    representation: [game.word(\"read\"), entity],\n                    sequence: [\n                        createNewLineAction(\"You read the note...\"),\n                        createNewLineAction(\"\" + entity.readable.message),\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    game.actions.tryOpen = function (entityId) {\n        var entity = game.getById(entityId);\n        if (entity.locked && entity.locked.isLocked) {\n            game.newLine(\"The \" + entity.baseName + \" seems to be locked...\");\n        }\n        else if (entity.closed === true) {\n            entity.closed = false;\n            game.newLine(\"You open the \" + entity.baseName);\n            game.newLine(\"It contains: \" + game\n                .getChildren(entity)\n                .map(function (e) { return e.baseName; })\n                .join(\",\"));\n        }\n    };\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.closed && game.isAccessible(e); }); _i < _a.length; _i++) {\n                var entity = _a[_i];\n                intents.push({\n                    representation: [game.word(\"open\"), entity],\n                    sequence: [\n                        {\n                            func: \"tryOpen\",\n                            args: [entity.id],\n                        },\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    game.actions.punch = function (attackerId, targetId) {\n        var attacker = game.getById(attackerId);\n        var target = game.getById(targetId);\n        var sounds = [\"POW!\", \"Bam!\", \"Boom!\", \"Zock!\"];\n        game.newLine(\"You punch the \" + target.baseName + \"! \" + sounds[Math.floor(Math.random() * sounds.length)]);\n        if (target.health < 5) {\n            game.newLine(\"Some fluff flies out of the ruptures. 1 damage!\");\n            target.health -= 1;\n            game.queueEvent({\n                type: \"damageDealt\",\n                from: attacker,\n                to: target,\n            });\n        }\n    };\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.health > 0; }); _i < _a.length; _i++) {\n                var entity = _a[_i];\n                intents.push({\n                    representation: [\n                        game.word(\"attack\"),\n                        entity,\n                        game.word(\"with fists\"),\n                    ],\n                    sequence: [\n                        createWaitAction(5),\n                        {\n                            func: \"punch\",\n                            args: [player.id, entity.id],\n                        },\n                        createWaitAction(2),\n                        {\n                            func: \"punch\",\n                            args: [player.id, entity.id],\n                        },\n                        createWaitAction(2),\n                        {\n                            func: \"punch\",\n                            args: [player.id, entity.id],\n                        },\n                        createWaitAction(2),\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    game.actions.sipFrom = function (containerId) {\n        var container = game.getById(containerId);\n        for (var _i = 0, _a = game.getChildren(container).filter(function (e) { return e.fluid; }); _i < _a.length; _i++) {\n            var fluid = _a[_i];\n            if (fluid.turboTea) {\n                game.newLine(\"You feel like a 400 IQ, cupboard-opening, killing machine! In fact, you feel so good you feel like giving Gardens some feedback on their game!\");\n            }\n            else if (fluid.tea) {\n                game.newLine(\"It's not too bad. It's... fine.\");\n            }\n            else {\n                game.newLine(\"It's important to stay hydrated, I guess.\");\n            }\n        }\n    };\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) {\n                return fluidsIn(e);\n            }); _i < _a.length; _i++) {\n                var nonEmptyFluidContainer = _a[_i];\n                intents.push({\n                    representation: [\n                        game.word(\"sip from\"),\n                        nonEmptyFluidContainer,\n                    ],\n                    sequence: [\n                        createNewLineAction(\"You sip from the \" + nonEmptyFluidContainer.baseName + \".\"),\n                        createWaitAction(20),\n                        {\n                            func: \"sipFrom\",\n                            args: [nonEmptyFluidContainer.id],\n                        },\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    game.actions.readyClaws = function (targetId) {\n        var target = game.getById(targetId);\n        if (target.health === 5)\n            game.newLine(\"You let out a piercing shriek as you ready your razor-sharp, glassy claws!\");\n        else\n            game.newLine(\"You ready your claws again!\");\n    };\n    game.actions.claw = function (attackerId, targetId) {\n        var attacker = game.getById(attackerId);\n        var target = game.getById(targetId);\n        game.newLine(\"You tear out the \" + target.baseName + \"'s insides for 2 damage!\");\n        target.health -= 2;\n        game.queueEvent({\n            type: \"damageDealt\",\n            from: attacker,\n            to: target,\n            amount: 2,\n        });\n    };\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.health > 0; }); _i < _a.length; _i++) {\n                var target = _a[_i];\n                intents.push({\n                    representation: [\n                        game.word(\"attack\"),\n                        target,\n                        game.word(\"with claws\"),\n                    ],\n                    sequence: [\n                        { func: \"readyClaws\", args: [target.id] },\n                        createWaitAction(10),\n                        { func: \"claw\", args: [player.id, target.id] },\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    game.addHandler(0, {\n        on_damageDealt: function (data) {\n            game.newLine(\"Damage dealt by \" + data.from.baseName);\n            if (data.to.health <= 0 && !data.to.dead) {\n                data.to.dead = true;\n                game.newLine(\"You have defeated your first enemy, a vile \" + data.to.baseName + \". It drops a teabag!\");\n                data.to.baseName = \"dead \" + data.to.baseName;\n                data.health = undefined;\n                game.addEntity({\n                    baseName: \"VICTORIOUS teabag\",\n                    item: true,\n                    infusable: {\n                        flavour: \"VICTORY\",\n                    },\n                }, game.getParent(data.to));\n            }\n        },\n    });\n    game.addHandler(0, {\n        on_tick: function (data) {\n            var _loop_1 = function (stove_1) {\n                if (stove_1.active) {\n                    stove_1.ctr += 1;\n                    // put out a message regularly\n                    if (stove_1.ctr >= 2) {\n                        stove_1.ctr = 0;\n                        game.newLine(\"The stove's flame burns a warm orange.\");\n                    }\n                    var _loop_2 = function (containerOnStove) {\n                        // game.newLine(\n                        //     `The stove heats up the ${containerOnStove.baseName}`\n                        // );\n                        for (var _i = 0, _a = game.entities.filter(function (fluid) {\n                            return fluid.fluid &&\n                                game.isParent(containerOnStove, fluid);\n                        }); _i < _a.length; _i++) {\n                            var fluid = _a[_i];\n                            // game.newLine(\n                            //     `The stove heats up the ${fluid.baseName} in the ${containerOnStove.baseName}`\n                            // );\n                            fluid.temperature += 1;\n                            if (fluid.temperature == 23) {\n                                game.newLine(\"The \" + containerOnStove.baseName + \" is filled with hot \" + fluid.baseName + \"!\");\n                            }\n                        }\n                    };\n                    // heat up fluid inside containers on stove\n                    for (var _i = 0, _a = game.entities.filter(function (containerOnStove) {\n                        return containerOnStove.fluidContainer &&\n                            game.isParent(stove_1, containerOnStove);\n                    }); _i < _a.length; _i++) {\n                        var containerOnStove = _a[_i];\n                        _loop_2(containerOnStove);\n                    }\n                }\n            };\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.baseName === \"stove\"; }); _i < _a.length; _i++) {\n                var stove_1 = _a[_i];\n                _loop_1(stove_1);\n            }\n        },\n    });\n    game.addHandler(900, {\n        on_tick: function (data) {\n            var _loop_3 = function (fluidContainer) {\n                for (var _i = 0, _a = game.entities.filter(function (hotFluid) {\n                    return hotFluid.fluid &&\n                        game.isParent(fluidContainer, hotFluid) &&\n                        hotFluid.temperature > 23;\n                }); _i < _a.length; _i++) {\n                    var hotFluid = _a[_i];\n                    var count = 0;\n                    var prefix = \"\";\n                    // if infusable in container and hot fluid\n                    for (var _b = 0, _c = game.entities.filter(function (e) { return e.infusable && game.isParent(fluidContainer, e); }); _b < _c.length; _b++) {\n                        var infusingTeabag = _c[_b];\n                        count += 1;\n                        prefix += infusingTeabag.infusable.flavour + \" \";\n                        game.queueEvent({ type: \"teaMade\" });\n                        if (count < 3) {\n                            hotFluid.baseName = prefix + \" tea\";\n                            hotFluid.tea = true;\n                        }\n                        else {\n                            hotFluid.baseName = \"TURBO TESTER TEA\";\n                            if (!hotFluid.turboTea) {\n                                hotFluid.turboTea = true;\n                                game.newLine(\"TOTAL VICTORY ACHIEVED! Enjoy your tea!\");\n                            }\n                        }\n                        // console.log(\"hotFluid\", hotFluid);\n                    }\n                }\n            };\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.fluidContainer; }); _i < _a.length; _i++) {\n                var fluidContainer = _a[_i];\n                _loop_3(fluidContainer);\n            }\n        },\n    });\n    game.addEntity({\n        baseName: \"winBehaviourState\",\n        invisible: true,\n        winBehaviorState: { won: false, uberWon: false },\n    });\n    game.addHandler(1000, {\n        on_teaMade: function (data) {\n            var state = game.entities.filter(function (e) { return e.winBehaviorState; })[0];\n            if (state.winBehaviorState.won === false) {\n                game.newLine(\"Congratulations, you have made tea! Did you find all three teabags? I wonder what happens if you infuse them all at once...\");\n                state.winBehaviorState.won = true;\n            }\n        },\n    });\n    game.addEntity({\n        baseName: \"timer\",\n        invisible: true,\n        timer: { time: -1 },\n    });\n    var area = game.entities.filter(function (e) { return e.baseName === \"room A\"; })[0];\n    console.log({ teaModRoom: area });\n    var stove = game.addEntity({\n        baseName: \"stove\",\n        active: false,\n        surface: true,\n    }, area);\n    var faucet = game.addEntity({\n        baseName: \"faucet\",\n        fluidSource: \"water\",\n    }, area);\n    var punchingBag = game.addEntity({\n        baseName: \"punching bag\",\n        health: 5,\n    }, area);\n    var teaCupboard = game.addEntity({\n        baseName: \"tea cupboard\",\n        solidContainer: true,\n        closed: true,\n    }, area);\n    var cranberryTeabag = game.addEntity({\n        baseName: \"cranberry teabag\",\n        item: true,\n        infusable: {\n            flavour: \"OBVIOUS\",\n        },\n    }, teaCupboard);\n    var table = game.addEntity({\n        baseName: \"table\",\n        surface: true,\n    }, area);\n    var knife = game.addEntity({\n        baseName: \"knife\",\n        item: true,\n    }, table, \"on\");\n    var cup = game.addEntity({\n        baseName: \"cup\",\n        item: true,\n        fluidContainer: true,\n    }, table, \"on\");\n    var bowl = game.addEntity({\n        baseName: \"bowl\",\n        item: true,\n        fluidContainer: true,\n    }, table, \"on\");\n    var note = game.addEntity({\n        baseName: \"super secret note\",\n        item: true,\n        readable: {\n            message: \"The note says: \\\"The password is 6...\",\n        },\n    }, table, \"on\");\n    var lockedChest = game.addEntity({\n        baseName: \"locked chest\",\n        solidContainer: true,\n        closed: true,\n        item: true,\n        locked: { isLocked: true, password: \"6\" },\n    }, table, \"on\");\n    var smallerChest = game.addEntity({\n        baseName: \"smaller chest\",\n        solidContainer: true,\n        closed: true,\n        item: true,\n    }, lockedChest, \"in\");\n    var evenSmallerChest = game.addEntity({\n        baseName: \"even smaller chest\",\n        solidContainer: true,\n        closed: true,\n        item: true,\n    }, smallerChest, \"in\");\n    var secretTeabag = game.addEntity({\n        baseName: \"secretive teabag\",\n        item: true,\n        infusable: { flavour: \"SECRET\" },\n    }, smallerChest, \"in\");\n}\nexports.loadMod = loadMod;\nmodule.exports = { loadMod: loadMod };\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ticks per second\nexports.tps = 6;\n// milliseconds per tick\nexports.mpt = 300;\nfunction s(nr) {\n    return exports.tps * nr;\n}\nexports.s = s;\nfunction m(nr) {\n    return exports.tps * nr * 60;\n}\nexports.m = m;\nfunction h(nr) {\n    return exports.tps * nr * 3600;\n}\nexports.h = h;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar GameModule = require(\"./GameModule\");\nvar PlayerModule = require(\"./PlayerModule\");\nvar teaRoomMod = require(\"./modTeaRoom\");\nvar debugMod = require(\"./modDebug\");\n// HACK\n// let newLine = utils.newLine;\n// import { newLine } from \"./utils\";\nvar game = new GameModule.Game();\nvar player = new PlayerModule.Player();\ngame.player = player;\n// load mods\nvar debug = false;\nvar areaA = game.addEntity({\n    baseName: \"room A\",\n    area: true,\n});\nvar areaB = game.addEntity({\n    baseName: \"room B\",\n    area: true,\n});\nvar areaC = game.addEntity({\n    baseName: \"room C\",\n    area: true,\n});\ngame.addEntity({\n    path: {\n        from: areaA.id,\n        to: areaB.id,\n        distance: 10,\n    },\n});\ngame.addEntity({\n    path: {\n        from: areaB.id,\n        to: areaC.id,\n        distance: 20,\n    },\n});\ngame.addEntity({\n    path: {\n        from: areaC.id,\n        to: areaB.id,\n        distance: 4,\n    },\n});\ngame.addEntity(player, areaA);\nteaRoomMod.loadMod(game);\ndebugMod.loadMod(game);\nconsole.log(game.entities);\nvar keys = \"abcdefghijklmnopqrstuwxyz\".split(\"\");\ndocument.addEventListener(\"keypress\", function (event) {\n    var name = event.key;\n    if (name === \"`\") {\n        game.playRandomly = !game.playRandomly;\n    }\n    if (player.picking && keys.indexOf(name) !== -1) {\n        // alert(`pressed ${keys.indexOf(name)} of ${keys}`)\n        player.pickNextWord(keys.indexOf(name));\n        player.setOptionsUI();\n    }\n}, false);\nplayer.updateCommandUI();\ngame.updateEntityTreeUI();\ngame.getIntents();\nconsole.log({ \"all intents\": player.getAllIntents() });\n// for (let intent of player.getAllIntents()) {\n//     console.log({ intent })\n// }\nfunction debugText(text) {\n    document.getElementById(\"debug\").innerText = text;\n}\n"],"names":[],"sourceRoot":""}