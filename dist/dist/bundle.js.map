{"version":3,"file":"./dist/bundle.js","mappings":";;;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA,aAAa,mBAAO,CAAC,iCAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,6BAA6B,IAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,gCAAgC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,qBAAqB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yCAAyC;AACjF;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB,GAAG,mBAAmB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,iBAAiB,GAAG,gBAAgB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,YAAY,cAAc,GAAG;AAC3D,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,4DAA4D,GAAG,gBAAgB;AAClJ;AACA,sDAAsD,gBAAgB;AACtE;AACA;AACA;AACA;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,+BAA+B,GAAG,gBAAgB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8BAA8B,GAAG,gBAAgB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,kEAAkE,iCAAiC,GAAG,gBAAgB;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,YAAY;AACZ;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,oBAAoB,sBAAsB;AAC1C,qBAAqB,aAAa;AAClC;AACA;AACA;;;;;;;;;;;AC5ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB,4BAA4B,kCAAkC;AAC7G,wDAAwD,4BAA4B;AACpF;AACA;AACA;AACA,+BAA+B,0CAA0C;AACzE;AACA;AACA;AACA;AACA,sDAAsD,uBAAuB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAwC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,0DAA0D,GAAG,gBAAgB;AACzI;AACA,0BAA0B,uCAAuC;AACjE;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oBAAoB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA,CAAC;AACD,cAAc;;;;;;;;;;;AC3LD;AACb;AACA,kDAAkD,QAAQ;AAC1D,yCAAyC,QAAQ;AACjD,yDAAyD,QAAQ;AACjE;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,iCAAU;AAC/B;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,+CAA+C,MAAM;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4BAA4B;AAC9C,kBAAkB,6BAA6B;AAC/C,kBAAkB,6BAA6B;AAC/C,kBAAkB,+BAA+B;AACjD,kBAAkB,+BAA+B;AACjD;AACA,sDAAsD,yBAAyB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,uBAAuB,GAAG,gBAAgB;AAChH;AACA,0EAA0E,0CAA0C,GAAG,gBAAgB;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,iEAAiE,gBAAgB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,8DAA8D,GAAG,gBAAgB;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,kFAAkF,gBAAgB;AAClG;AACA,8EAA8E,gBAAgB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,wCAAwC,GAAG,gBAAgB;AACjI;AACA,0EAA0E,mBAAmB,GAAG,gBAAgB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,sEAAsE,6CAA6C,GAAG,gBAAgB;AACtI;AACA,0EAA0E,0BAA0B,GAAG,gBAAgB;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,sDAAsD,GAAG,gBAAgB;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,sEAAsE,qDAAqD,GAAG,gBAAgB;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,0CAA0C,GAAG,gBAAgB;AACnI;AACA,iCAAiC,SAAS;AAC1C,wCAAwC,SAAS;AACjD,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,sEAAsE,oBAAoB,GAAG,gBAAgB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,0CAA0C,GAAG,gBAAgB;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAA+C;AAC7E;AACA;AACA;AACA;AACA;AACA,sEAAsE,sBAAsB,GAAG,gBAAgB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,gFAAgF,iBAAiB,GAAG,gBAAgB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sEAAsE,sBAAsB,GAAG,gBAAgB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uCAAuC;AACjE;AACA,0BAA0B,4CAA4C;AACtE;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,0BAA0B;AACnF;AACA;AACA;AACA;AACA,yBAAyB,GAAG,gBAAgB;AAC5C;AACA;AACA,6DAA6D,gBAAgB,SAAS,0BAA0B;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,GAAG,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,sEAAsE,gCAAgC,GAAG,gBAAgB;AACzH;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAG,gBAAgB;AACpC;AACA;AACA;AACA;AACA,8EAA8E,yDAAyD,GAAG,gBAAgB;AAC1J;AACA;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,0BAA0B,GAAG,gBAAgB;AACnH;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD,KAAK;AACL;AACA;AACA,4DAA4D,4BAA4B;AACxF;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B,KAAK;AACL;AACA,mBAAmB;;;;;;;;;;;ACznBN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;;;;;;;UCjBT;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,yCAAc;AACvC,mBAAmB,mBAAO,CAAC,6CAAgB;AAC3C;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,yCAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,cAAc,+BAA+B;AAC7C,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB,KAAK,KAAK;AAC1D;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,cAAc,uCAAuC;AACrD;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA","sources":["webpack://starspawn/./src/GameModule.ts","webpack://starspawn/./src/PlayerModule.ts","webpack://starspawn/./src/modTeaRoom.ts","webpack://starspawn/./src/timing.ts","webpack://starspawn/webpack/bootstrap","webpack://starspawn/./src/index.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// let utils = require(\"./utils\")\n// let timing = require(\"./timing\");\nvar timing = require(\"./timing\");\nvar Game = /** @class */ (function () {\n    function Game() {\n        this.id = 0;\n        this.entities = [];\n        this.words = {};\n        this.actionId = 0;\n        this.history = [];\n        this.log = [];\n        this.intentsReady = true;\n        this.signalsReady = true;\n        this.queue = []; // [Action*]\n        this.receivers = []; // {on_signalType:func()}\n        this.time = 0;\n        this.player = null;\n        this.playRandomly = false;\n        this.actions = {};\n    }\n    Game.prototype.addEntity = function (entity, parentEntity, rel) {\n        if (parentEntity === void 0) { parentEntity = null; }\n        if (rel === void 0) { rel = null; }\n        this.entities.push(entity);\n        entity.id = this.id;\n        this.id += 1;\n        if (parentEntity !== null) {\n            this.setParent(parentEntity, entity, rel);\n        }\n        return entity;\n    };\n    Game.prototype.getById = function (id) {\n        var found = undefined;\n        for (var i = 0; i < this.entities.length; i++) {\n            if (this.entities[i].id === id) {\n                found = this.entities[i];\n            }\n        }\n        if (found === undefined)\n            throw \"object not found with id \" + id;\n        return found;\n    };\n    Game.prototype.getDepth = function (entity) {\n        var depth = 0;\n        while (this.getParent(entity) !== undefined) {\n            entity = this.getParent(entity);\n            depth += 1;\n        }\n        return depth;\n    };\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // PARENT\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    Game.prototype.setParent = function (parentEntity, childEntity, rel) {\n        if (rel === void 0) { rel = null; }\n        if (parentEntity === undefined ||\n            parentEntity.id === undefined ||\n            this.getById(parentEntity.id) === undefined)\n            throw \"Undefined parent.\";\n        this.unsetParent(childEntity);\n        childEntity.parent = parentEntity.id;\n        if (rel !== null) {\n            childEntity.rel = rel;\n        }\n    };\n    Game.prototype.setParentById = function (parentId, childId, rel) {\n        if (rel === void 0) { rel = null; }\n        this.setParent(this.getById(parentId), this.getById(childId), rel);\n    };\n    Game.prototype.unsetParent = function (childEntity) {\n        childEntity.parent = undefined;\n    };\n    Game.prototype.isParent = function (parentEntity, childEntity) {\n        return parentEntity.id === childEntity.parent;\n    };\n    Game.prototype.getParent = function (childEntity) {\n        var parent = childEntity.parent === undefined\n            ? undefined\n            : this.getById(childEntity.parent);\n        return parent;\n    };\n    Game.prototype.getChildren = function (entity) {\n        // console.log(\"loop\", entity.id);\n        var contents = this.entities.filter(function (e) { return e.parent === entity.id; });\n        // let contents = this.entities.filter((e) => this.isParent(entity, e));\n        return contents;\n    };\n    Game.prototype.getChildrenById = function (id) {\n        return this.getChildren(this.getById(id));\n    };\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    Game.prototype.deleteById = function (id) {\n        // TODO? throw if not found\n        this.entities = this.entities.filter(function (e) { return e.id !== id; });\n    };\n    Game.prototype.isAccessible = function (entity) {\n        if (entity === undefined || this.getParent(entity) === undefined)\n            return true;\n        var parent = this.getParent(entity);\n        var accessible = (parent.closed === false || parent.closed === undefined) &&\n            (parent.locked === undefined || parent.locked.isLocked === false);\n        return accessible && this.isAccessible(parent);\n    };\n    Game.prototype.enqueue = function (action, i) {\n        if (i === void 0) { i = -1; }\n        if (i === -1) {\n            this.queue.push(action);\n        }\n        else {\n            this.queue.splice(i, 0, action);\n        }\n    };\n    Game.prototype.emitSignal = function (data) {\n        for (var _i = 0, _a = this.receivers; _i < _a.length; _i++) {\n            var receiver = _a[_i];\n            if (receiver[\"on_\" + data.type]) {\n                receiver[\"on_\" + data.type](data);\n            }\n        }\n    };\n    Game.prototype.processAction = function (action) {\n        if (action.maxDuration === undefined) {\n            action.maxDuration = action.duration || 0;\n            this.actionId += 1;\n            action.id = this.actionId;\n            var logItem = {\n                id: action.id,\n            };\n            this.history.push(action);\n            this.log.push(logItem);\n        }\n        return action;\n    };\n    Game.prototype.updateLog = function () {\n        for (var i_1 = 0; i_1 < this.log.length; i_1++) {\n            var logItem = this.log[i_1];\n            var logId = logItem.id;\n            for (var hc = 0; hc < this.history.length; hc++) {\n                var action = this.history[hc];\n                var actionId = action.id;\n                // match log item to action\n                if (logId === actionId) {\n                    if (action.duration && action.duration > 0) {\n                        logItem.progressBar = \"[\" + (\"=\".repeat(action.maxDuration - action.duration) +\n                            \"-\".repeat(action.duration)) + \"]\";\n                        logItem.sticky = true;\n                    }\n                    else {\n                        logItem.progressBar = \"\";\n                        logItem.sticky = false;\n                    }\n                }\n            }\n        }\n        this.log.sort(function (a, b) { return (a.sticky && !b.sticky ? 1 : 0); });\n        // update UI\n        var display = document.getElementById(\"display\");\n        display.innerText = \"\";\n        var i = Math.max(0, this.log.length - 50);\n        for (var _i = 0, _a = this.log.slice(i); _i < _a.length; _i++) {\n            var logItem = _a[_i];\n            if (logItem.text) {\n                display.innerText += \"\\n\" + logItem.text;\n            }\n            if (logItem.progressBar) {\n                display.innerText += \"\\n\" + logItem.progressBar;\n            }\n        }\n        display.scrollTop = display.scrollHeight;\n        console.log(this.log);\n    };\n    Game.prototype.newLine = function (text) {\n        this.actionId += 1;\n        var logItem = {\n            text: \"\" + text,\n            id: this.actionId,\n        };\n        this.log.push(logItem);\n    };\n    Game.prototype.getIntents = function () {\n        var _this = this;\n        // get this tick's Actions {aedpcs} for every entity with intent (null or Intent)\n        this.queue = [];\n        this.intentsReady = true;\n        var _loop_1 = function (entity) {\n            var intent = entity.actor.intent;\n            // empty intent\n            if (!intent) {\n                this_1.intentsReady = false;\n                // hang and reset for player input\n                if (entity.player) {\n                    if (!entity.picking) {\n                        entity.picking = true;\n                        entity.setOptionsUI();\n                    }\n                    setTimeout(function () {\n                        var options = entity.getNextWords();\n                        if (_this.playRandomly) {\n                            if (entity.command.length > 0) {\n                                entity.pickNextWord(Math.floor(Math.random() * (options.length - 1)));\n                            }\n                            else {\n                                entity.pickNextWord(Math.floor(Math.random() * options.length));\n                            }\n                        }\n                        _this.getIntents();\n                    }, 100);\n                }\n            }\n            else if (intent && intent.sequence.length > 0) {\n                // extract actions and enqueue them\n                var ticks = 0;\n                // extract actions until we go over 1 tick\n                while (ticks === 0 && intent.sequence.length > 0) {\n                    // process and enqueue action\n                    intent.sequence[0] = this_1.processAction(intent.sequence[0]);\n                    var action = intent.sequence[0];\n                    this_1.enqueue(action);\n                    // queue up actions including the first with duration\n                    if (action.duration <= 0 || action.duration === undefined) {\n                        // instant action, keep queueing\n                        intent.sequence.splice(0, 1);\n                    }\n                    else if (action.duration > 0) {\n                        // action that will be taken multiple times\n                        ticks = action.duration;\n                        // end actions here\n                        if (action.duration <= 1) {\n                            intent.sequence.splice(0, 1);\n                        }\n                        action.duration -= 1;\n                        // this.newLine(\n                        //     `${action.duration}/${action.maxDuration}`\n                        // );\n                    }\n                    else {\n                        // throw `Not sure what this means`;\n                    }\n                }\n                if (intent.sequence.length === 0) {\n                    entity.actor.intent = null;\n                }\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, _a = this.entities.filter(function (e) { return e.actor; }); _i < _a.length; _i++) {\n            var entity = _a[_i];\n            _loop_1(entity);\n        }\n        // when ready, propagate signals\n        if (this.intentsReady) {\n            // queue up a tick signal\n            this.queue.push({ signals: [{ type: \"tick\" }] });\n            // newLine(`starting tick ${game.time}`);\n            this.propagateSignals();\n        }\n    };\n    Game.prototype.propagateSignals = function () {\n        // run through signal propagation and clearing, instant\n        this.signalsReady = false;\n        while (!this.signalsReady) {\n            this.signalsReady = true;\n            // for every unpropagated action with signals, propagate and clear signals\n            for (var _i = 0, _a = this.queue.filter(function (a) { return !a.propagated && a.signals && a.signals.length > 0; }); _i < _a.length; _i++) {\n                var action = _a[_i];\n                for (var _b = 0, _c = action.signals; _b < _c.length; _b++) {\n                    var signal = _c[_b];\n                    // new signal to propagate\n                    this.signalsReady = false;\n                    var type = signal.type;\n                    // send to every receiver\n                    for (var _d = 0, _e = this.receivers; _d < _e.length; _d++) {\n                        var receiver = _e[_d];\n                        if (receiver[\"on_\" + type]) {\n                            receiver[\"on_\" + type](signal);\n                        }\n                    }\n                }\n                // mark as propagated\n                action.propagated = true;\n            }\n        }\n        // reset propagation for actions with duration\n        for (var _f = 0, _g = this.queue.filter(function (a) { return a.propagated === true; }); _f < _g.length; _f++) {\n            var action = _g[_f];\n            action.propagated = false;\n        }\n        this.executeNext();\n    };\n    Game.prototype.executeNext = function () {\n        var _this = this;\n        // get next action to execute\n        if (this.queue.length > 0) {\n            var action = this.queue.shift();\n            if (action.func) {\n                if (this.actions[action.func]) {\n                    var func = this.actions[action.func];\n                    if (action.args) {\n                        func.apply(void 0, action.args);\n                    }\n                    else {\n                        func();\n                    }\n                }\n                else {\n                    throw \"Unknown action \" + action.func + \", args \" + action.args;\n                }\n            }\n            // execute the next instantly or with pause\n            if (action.pause) {\n                setTimeout(function () {\n                    _this.executeNext();\n                }, action.pause);\n            }\n            else {\n                this.executeNext();\n            }\n        }\n        else {\n            // loop again\n            this.time += 1;\n            this.updateUI();\n            this.getIntents();\n        }\n    };\n    Game.prototype.word = function (text) {\n        if (!this.words[text]) {\n            var word = { type: \"word\", baseName: text };\n            this.words[text] = word;\n        }\n        return this.words[text];\n    };\n    Game.prototype.updateUI = function () {\n        this.updateEntityTreeUI();\n        this.updateClockUI();\n        this.updateLog();\n    };\n    Game.prototype.updateEntityTreeUI = function () {\n        var _this = this;\n        // time\n        var ticks = this.time % timing.tps;\n        var hours = Math.floor(this.time / timing.tps / 3600);\n        var minutes = Math.floor(this.time / timing.tps / 60);\n        var seconds = Math.floor(this.time / timing.tps);\n        var game = this;\n        var treeNode = document.getElementById(\"entityTree\");\n        treeNode.innerHTML = \"Time: \" + hours + \":\" + minutes + \":\" + seconds + \":\" + ticks + \"\\n\\n</br>\";\n        // subtree\n        function indentedSubtree(entity, depth) {\n            if (depth === void 0) { depth = 0; }\n            if (!entity.baseName || entity.invisible)\n                return null;\n            var healthText = entity.health > 0 ? \"[\" + \"#\".repeat(entity.health) + \"]\" : \"\";\n            var focusedText = game.player.focus === entity.id ? \"(focused)\" : \"\";\n            var textNode = document.createElement(\"a\");\n            // textNode.style.color = \"lightgrey\";\n            textNode.innerText = \"|\" + \"----\".repeat(depth) + entity.baseName + \" \" + healthText + focusedText + \"\\n\";\n            textNode.className = \"treeObject\";\n            if (game.getChildren(entity).length > 0) {\n                for (var _i = 0, _a = game\n                    .getChildren(entity)\n                    .filter(function (e) { return game.isAccessible(e); }); _i < _a.length; _i++) {\n                    var child = _a[_i];\n                    var subtree = indentedSubtree(child, depth + 1);\n                    if (subtree !== null)\n                        textNode.appendChild(subtree);\n                }\n            }\n            // on click, focus action\n            textNode.addEventListener(\"click\", function (e) {\n                e = window.event || e;\n                if (this === e.target) {\n                    game.player.focus = entity.id;\n                    game.player.command = [];\n                    game.player.setOptionsUI();\n                }\n                game.updateEntityTreeUI();\n            });\n            return textNode;\n        }\n        for (var _i = 0, _a = this.entities.filter(function (e) { return _this.getDepth(e) === 0; }); _i < _a.length; _i++) {\n            var entity = _a[_i];\n            var subtree = indentedSubtree(entity, 0);\n            if (subtree) {\n                treeNode.appendChild(subtree);\n            }\n        }\n    };\n    Game.prototype.updateClockUI = function () {\n        var clock = document.getElementById(\"clock\");\n        var ctx = clock.getContext(\"2d\");\n        var width = clock.clientWidth;\n        var height = clock.clientHeight;\n        // ctx.stroke = \"white\";\n        ctx.clearRect(0, 0, width, height);\n        ctx.fillText(\"\" + this.time, width / 2 - 6, height / 2 + 5);\n        // dots\n        ctx.save();\n        ctx.translate(width / 2, height / 2);\n        ctx.beginPath();\n        ctx.rotate(-Math.PI / 2);\n        for (var i = 0; i < 12; i++) {\n            ctx.moveTo(20, 0);\n            ctx.lineTo(25, 0);\n            ctx.rotate((2 * Math.PI) / 12);\n        }\n        ctx.stroke();\n        ctx.restore();\n        // ticks\n        ctx.save();\n        ctx.translate(width / 2, height / 2);\n        ctx.beginPath();\n        ctx.rotate(-Math.PI / 2);\n        ctx.rotate((2 * Math.PI * this.time) / timing.tps);\n        ctx.arc(10, 0, 2, 0, 2 * Math.PI);\n        ctx.stroke();\n        ctx.restore();\n        // seconds\n        // ticks\n        ctx.save();\n        ctx.translate(width / 2, height / 2);\n        ctx.beginPath();\n        ctx.rotate(-Math.PI / 2);\n        ctx.rotate((2 * Math.PI * this.time) / timing.tps / 60);\n        ctx.moveTo(10, 0);\n        ctx.lineTo(25, 0);\n        ctx.stroke();\n        ctx.restore();\n    };\n    return Game;\n}());\nexports.Game = Game;\n// let g = new Game();\n// let teapot = g.buildObject(\n//     {\n//         teapot: true,\n//     },\n//     [\n//         [\"is\", { fluidContainer: true }],\n//         [\"has\", { spout: true }],\n//     ]\n// );\n// console.log(g.entities);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Player = /** @class */ (function () {\n    function Player() {\n        this.baseName = \"player\";\n        this.player = true;\n        this.actor = {\n            intent: null,\n        };\n        this.picking = false;\n        this.command = [];\n        this.patterns = [];\n        this.focus = null;\n        this.id = -1;\n    }\n    Player.prototype.addPattern = function (pattern) {\n        this.patterns.push(pattern);\n    };\n    Player.prototype.getAllIntents = function () {\n        var intents = [];\n        for (var _i = 0, _a = this.patterns; _i < _a.length; _i++) {\n            var pattern = _a[_i];\n            for (var _b = 0, _c = pattern.intents(); _b < _c.length; _b++) {\n                var intent = _c[_b];\n                intents.push(intent);\n            }\n        }\n        return intents;\n    };\n    //^ getAllIntents(), command\n    Player.prototype.getValidIntents = function () {\n        // get remaining Intents that match the command and focus so far\n        var validIntents = [];\n        for (var _i = 0, _a = this.getAllIntents(); _i < _a.length; _i++) {\n            var intent = _a[_i];\n            // check intent for command validity\n            var cmdValid = true;\n            for (var i = 0; i < this.command.length; i++) {\n                if (intent.representation[i] !== this.command[i]) {\n                    cmdValid = false;\n                }\n            }\n            // check intent for focus validity, if any focus\n            var focusValid = this.focus ? false : true;\n            for (var _b = 0, _c = intent.representation; _b < _c.length; _b++) {\n                var entity = _c[_b];\n                if (entity.id === this.focus) {\n                    focusValid = true;\n                }\n            }\n            if (cmdValid && focusValid) {\n                validIntents.push(intent);\n            }\n        }\n        return validIntents;\n    };\n    //^ getValidIntents(), command\n    // get options for next word to pick\n    Player.prototype.getNextWords = function () {\n        var options = [];\n        var validIntents = this.getValidIntents();\n        // console.log(`${validIntents.length} valid commands at command ${this.command.map(w => w.baseName)}`)\n        for (var _i = 0, validIntents_1 = validIntents; _i < validIntents_1.length; _i++) {\n            var intent = validIntents_1[_i];\n            // if the intent is the same length as the command, it can be confirmed\n            if (intent.representation.length == this.command.length) {\n                options.push({ baseName: \"> confirm <\", type: \"confirm\" });\n            }\n            else {\n                var newOption = intent.representation[this.command.length];\n                var duplicateThing = false;\n                for (var _a = 0, options_1 = options; _a < options_1.length; _a++) {\n                    var option = options_1[_a];\n                    if (newOption === option) {\n                        duplicateThing = true;\n                    }\n                }\n                if (!duplicateThing) {\n                    options.push(newOption);\n                }\n            }\n        }\n        if (this.command.length > 0) {\n            options.push({ baseName: \"> cancel <\", type: \"cancel\" });\n        }\n        return options;\n    };\n    //^ updateCommandUI()\n    Player.prototype.pickNextWord = function (optionI) {\n        var options = this.getNextWords();\n        if (options[optionI].type === \"confirm\") {\n            this.setIntent();\n        }\n        else if (options[optionI].type === \"cancel\") {\n            this.command = [];\n            this.focus = null;\n        }\n        else {\n            this.command.push(options[optionI]);\n        }\n        this.updateCommandUI();\n    };\n    // getValidIntents(), clearCommand()\n    // set intent and clear the command\n    Player.prototype.setIntent = function () {\n        var _this = this;\n        // get valid intents\n        var intents = this.getValidIntents();\n        // from intents of command's length\n        for (var _i = 0, _a = intents.filter(function (i) { return i.representation.length === _this.command.length; }); _i < _a.length; _i++) {\n            var intent = _a[_i];\n            console.log({ intent: intent, command: this.command });\n            var valid = true;\n            for (var i = 0; i < intent.representation.length; i++) {\n                if (intent.representation[i] !== this.command[i]) {\n                    console.log(\"execution wonk, not one valid action\");\n                    valid = false;\n                }\n            }\n            if (valid) {\n                // set intent, not picking\n                this.actor.intent = intent;\n                // intent.totalDuration = intent.sequence.reduce(\n                //     (sum, action) => sum + action.duration || 0,\n                //     0\n                // );\n                // intent.elapsed = 0;\n                // console.log({ intent });\n                this.picking = false;\n                this.focus = null;\n                // clear command\n                this.command = [];\n                this.updateCommandUI();\n                return;\n            }\n        }\n    };\n    Player.prototype.updateCommandUI = function () {\n        document.getElementById(\"command\").innerHTML =\n            \">\" + this.command.map(function (e) { return e.baseName; }).join(\" \");\n    };\n    Player.prototype.clearOptionsUI = function () {\n        document.getElementById(\"options\").innerHTML = \"\";\n    };\n    Player.prototype.setOptionsUI = function () {\n        var _this = this;\n        document.getElementById(\"options\").innerHTML = \"\";\n        if (!this.picking)\n            return;\n        // get the next words, and create an element for each on document\n        var options = this.getNextWords();\n        var keys = \"abcdefghijklmnopqrstuwxyz\".split(\"\");\n        var _loop_1 = function (i) {\n            var optionText = options[i].baseName;\n            // create a span with the optionText baseName\n            shortcutNode = document.createElement(\"a\");\n            // shortcutNode.style.color = \"lightgrey\";\n            shortcutNode.innerText = keys[i] + \") \";\n            // keyboard shortcutNode\n            optionNode = document.createElement(\"a\");\n            // optionNode.style.color = \"white\";\n            optionNode.innerText = optionText;\n            shortcutNode.appendChild(optionNode);\n            document.getElementById(\"options\").appendChild(shortcutNode);\n            // when the span is clicked, handle using that optionText\n            // REFACTOR: bad\n            shortcutNode.addEventListener(\"click\", function () {\n                _this.pickNextWord(i);\n                _this.setOptionsUI();\n            });\n            if (options[i].type === \"confirm\") {\n                shortcutNode.className = \"confirm\";\n            }\n            else if (options[i].type === \"cancel\") {\n                shortcutNode.className = \"cancel\";\n            }\n            else {\n                shortcutNode.className = \"choice\";\n            }\n        };\n        var shortcutNode, optionNode;\n        for (var i = 0; i < options.length; i++) {\n            _loop_1(i);\n        }\n    };\n    return Player;\n}());\nexports.Player = Player;\n","\"use strict\";\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar timing = require(\"./timing\");\nfunction loadMod(player, game) {\n    game.actions.newLine = function () {\n        var _a;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return (_a = game.newLine).call.apply(_a, __spreadArrays([game], args));\n    };\n    // let newLine = game.newLine;\n    game.actions.wait = function (ticks) {\n        if (ticks === void 0) { ticks = 0; }\n        // game.newLine(`Still waiting... of ${ticks}`);\n    };\n    function createNewLineAction(text) {\n        return {\n            func: \"newLine\",\n            args: [text],\n        };\n    }\n    function createWaitAction(ticks, processText) {\n        if (processText === void 0) { processText = \"Waiting...\"; }\n        return {\n            func: \"wait\",\n            args: [ticks],\n            duration: ticks,\n            pause: timing.mpt / Math.pow(ticks, 1),\n            processText: processText,\n        };\n    }\n    // wait various durations\n    player.patterns.push({\n        intents: function () {\n            var intents = [];\n            var durations = [\n                { baseName: \"1 tick\", dur: 1 },\n                { baseName: \"3 ticks\", dur: 3 },\n                { baseName: \"6 ticks\", dur: 6 },\n                { baseName: \"12 ticks\", dur: 12 },\n                { baseName: \"60 ticks\", dur: 60 },\n            ];\n            for (var _i = 0, durations_1 = durations; _i < durations_1.length; _i++) {\n                var duration = durations_1[_i];\n                var intent = {\n                    representation: [\n                        game.word(\"wait\"),\n                        game.word(duration.baseName),\n                    ],\n                    sequence: [\n                        createNewLineAction(\"You wait \" + duration.dur + \" ticks.\"),\n                        createWaitAction(duration.dur),\n                    ],\n                };\n                intents.push(intent);\n            }\n            return intents;\n        },\n    });\n    game.actions.fillFrom = function (fluidSourceId, fluidContainerId) {\n        var fluidSource = game.getById(fluidSourceId);\n        var fluidContainer = game.getById(fluidContainerId);\n        var fluid = game.addEntity({\n            baseName: fluidSource.fluidSource,\n            fluid: true,\n            temperature: 20,\n        }, fluidContainer);\n        game.newLine(\"You fill up the \" + fluidContainer.baseName + \" from the \" + fluidSource.baseName + \" with \" + fluid.baseName);\n    };\n    function fluidsIn(fluidContainer) {\n        var fluidChildren = game\n            .getChildren(fluidContainer)\n            .filter(function (e) { return e.fluid; });\n        return fluidChildren.length > 0;\n    }\n    // fill container from fluidSource\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.fluidSource; }); _i < _a.length; _i++) {\n                var fluidSource = _a[_i];\n                for (var _b = 0, _c = game.entities.filter(function (e) { return e.fluidContainer && !fluidsIn(e); }); _b < _c.length; _b++) {\n                    var nonEmptyFluidContainer = _c[_b];\n                    intents.push({\n                        representation: [\n                            game.word(\"fill\"),\n                            nonEmptyFluidContainer,\n                            game.word(\"from\"),\n                            fluidSource,\n                        ],\n                        sequence: [\n                            createWaitAction(3, \"Filling\"),\n                            {\n                                func: \"fillFrom\",\n                                args: [\n                                    fluidSource.id,\n                                    nonEmptyFluidContainer.id,\n                                ],\n                                duration: 1,\n                            },\n                            createWaitAction(3, \"Recovering\"),\n                        ],\n                    });\n                    // throw \"HALT\"\n                }\n            }\n            return intents;\n        },\n    });\n    game.actions.emptyContainer = function (containerId) {\n        var container = game.getById(containerId);\n        var containerParent = game.getParent(container);\n        game.newLine(\"You empty the \" + container.baseName + \" on the \" + containerParent.baseName + \".\");\n        for (var _i = 0, _a = game.getChildrenById(containerId); _i < _a.length; _i++) {\n            var child = _a[_i];\n            if (child.fluid) {\n                game.deleteById(child.id);\n            }\n            else {\n                game.setParent(containerParent, child);\n            }\n        }\n    };\n    player.addPattern({\n        // empty container\n        intents: function () {\n            var intents = [];\n            // nonempty fluid containers\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.fluidContainer && game.getChildren(e).length !== 0; }); _i < _a.length; _i++) {\n                var nonEmptyFluidContainer = _a[_i];\n                intents.push({\n                    representation: [\n                        game.word(\"empty\"),\n                        nonEmptyFluidContainer,\n                    ],\n                    sequence: [\n                        createWaitAction(1),\n                        {\n                            func: \"emptyContainer\",\n                            args: [nonEmptyFluidContainer.id],\n                        },\n                        createWaitAction(1),\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    game.actions.pourXintoY = function (sourceId, destinationId) {\n        var source = game.getById(sourceId);\n        var destination = game.getById(destinationId);\n        for (var _i = 0, _a = game.getChildren(source); _i < _a.length; _i++) {\n            var child = _a[_i];\n            game.newLine(\"You pour the \" + child.baseName + \" from the \" + source.baseName + \" into the \" + destination.baseName + \".\");\n            game.setParent(destination, child);\n        }\n    };\n    player.addPattern({\n        // pour X into Y\n        intents: function () {\n            var intents = [];\n            var isNonEmptyFluidContainer = function (e) {\n                return e.fluidContainer && game.getChildren(e).length !== 0;\n            };\n            var isEmptyContainer = function (e) { return e.fluidContainer && !fluidsIn(e); };\n            for (var _i = 0, _a = game.entities.filter(isNonEmptyFluidContainer); _i < _a.length; _i++) {\n                var sourceContainer = _a[_i];\n                for (var _b = 0, _c = game.entities.filter(isEmptyContainer); _b < _c.length; _b++) {\n                    var destinationContainer = _c[_b];\n                    intents.push({\n                        representation: [\n                            game.word(\"pour\"),\n                            sourceContainer,\n                            game.word(\"into\"),\n                            destinationContainer,\n                        ],\n                        sequence: [\n                            {\n                                func: \"pourXintoY\",\n                                args: [\n                                    sourceContainer.id,\n                                    destinationContainer.id,\n                                ],\n                            },\n                        ],\n                    });\n                }\n            }\n            return intents;\n        },\n    });\n    game.actions.setParentById = function (parentId, childId, rel) {\n        return game.setParentById(parentId, childId, rel);\n    };\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.item && game.isAccessible(e); }); _i < _a.length; _i++) {\n                var entity = _a[_i];\n                for (var _b = 0, _c = game.entities.filter(function (e) { return e.surface; }); _b < _c.length; _b++) {\n                    var surface = _c[_b];\n                    intents.push({\n                        representation: [\n                            game.word(\"put\"),\n                            entity,\n                            game.word(\"on\"),\n                            surface,\n                        ],\n                        sequence: [\n                            createNewLineAction(\"You put the \" + entity.baseName + \" on the \" + surface.baseName),\n                            {\n                                func: \"setParentById\",\n                                args: [surface.id, entity.id, \"on\"],\n                            },\n                        ],\n                    });\n                }\n            }\n            return intents;\n        },\n    });\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.infusable && game.isAccessible(e); }); _i < _a.length; _i++) {\n                var infusable = _a[_i];\n                for (var _b = 0, _c = game.entities.filter(function (e) { return e.fluidContainer; }); _b < _c.length; _b++) {\n                    var fluidContainer = _c[_b];\n                    intents.push({\n                        representation: [\n                            game.word(\"put\"),\n                            infusable,\n                            game.word(\"in\"),\n                            fluidContainer,\n                        ],\n                        sequence: [\n                            {\n                                func: \"setParentById\",\n                                args: [fluidContainer.id, infusable.id, \"in\"],\n                            },\n                            createWaitAction(3),\n                        ],\n                    });\n                }\n            }\n            return intents;\n        },\n    });\n    game.actions.switchActive = function (switchableId) {\n        var switchable = game.getById(switchableId);\n        switchable.active = !switchable.active;\n    };\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.active !== undefined && e.active === false; }); _i < _a.length; _i++) {\n                var entity = _a[_i];\n                intents.push({\n                    representation: [game.word(\"turn on\"), entity],\n                    sequence: [\n                        createNewLineAction(\"You turn on the \" + entity.baseName),\n                        {\n                            func: \"switchActive\",\n                            args: [entity.id],\n                        },\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.active !== undefined && e.active === true; }); _i < _a.length; _i++) {\n                var entity = _a[_i];\n                intents.push({\n                    representation: [game.word(\"turn off\"), entity],\n                    sequence: [\n                        createNewLineAction(\"You turn off the \" + entity.baseName),\n                        {\n                            func: \"switchActive\",\n                            args: [entity.id],\n                        },\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    game.actions.tryUnlock = function (chestId, trialPassword) {\n        var chest = game.getById(chestId);\n        if (trialPassword === chest.locked.password) {\n            chest.locked.isLocked = false;\n            game.newLine(\"The locks click open.\");\n        }\n        else {\n            game.newLine(\"Incorrect password.\");\n        }\n    };\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.locked && game.isAccessible(e); }); _i < _a.length; _i++) {\n                var chest = _a[_i];\n                for (var i0 = 0; i0 < 10; i0++) {\n                    // for (let i1 = 0; i1 < 10; i1++) {\n                    // for (let i2 = 0; i2 < 10; i2++) {\n                    // the sequence\n                    intents.push({\n                        representation: [\n                            game.word(\"unlock\"),\n                            chest,\n                            game.word(String(i0)),\n                        ],\n                        // representation: [game.word(`unlock`), chest, game.word(String(i0)), game.word(String(i1)), game.word(String(i2))],\n                        sequence: [\n                            {\n                                func: \"tryUnlock\",\n                                args: [chest.id, \"\" + i0],\n                            },\n                        ],\n                    });\n                    // }\n                    // }\n                }\n            }\n            return intents;\n        },\n    });\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.readable; }); _i < _a.length; _i++) {\n                var entity = _a[_i];\n                // the sequence\n                intents.push({\n                    representation: [game.word(\"read\"), entity],\n                    sequence: [\n                        createNewLineAction(\"You read the note...\"),\n                        createNewLineAction(\"\" + entity.readable.message),\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    game.actions.tryOpen = function (entityId) {\n        var entity = game.getById(entityId);\n        if (entity.locked && entity.locked.isLocked) {\n            game.newLine(\"The \" + entity.baseName + \" seems to be locked...\");\n        }\n        else if (entity.closed === true) {\n            entity.closed = false;\n            game.newLine(\"You open the \" + entity.baseName);\n            game.newLine(\"It contains: \" + game\n                .getChildren(entity)\n                .map(function (e) { return e.baseName; })\n                .join(\",\"));\n        }\n    };\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.closed && game.isAccessible(e); }); _i < _a.length; _i++) {\n                var entity = _a[_i];\n                intents.push({\n                    representation: [game.word(\"open\"), entity],\n                    sequence: [\n                        {\n                            func: \"tryOpen\",\n                            args: [entity.id],\n                        },\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    game.actions.punch = function (attackerId, targetId) {\n        var attacker = game.getById(attackerId);\n        var target = game.getById(targetId);\n        var sounds = [\"POW!\", \"Bam!\", \"Boom!\", \"Zock!\"];\n        game.newLine(\"You punch the \" + target.baseName + \"! \" + sounds[Math.floor(Math.random() * sounds.length)]);\n        if (target.health < 5) {\n            game.newLine(\"Some fluff flies out of the ruptures. 1 damage!\");\n            target.health -= 1;\n            game.emitSignal({ type: \"damageDealt\", by: attacker, to: target });\n        }\n    };\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.health > 0; }); _i < _a.length; _i++) {\n                var entity = _a[_i];\n                intents.push({\n                    representation: [\n                        game.word(\"attack\"),\n                        entity,\n                        game.word(\"with fists\"),\n                    ],\n                    sequence: [\n                        createWaitAction(5),\n                        {\n                            func: \"punch\",\n                            args: [player.id, entity.id],\n                        },\n                        createWaitAction(2),\n                        {\n                            func: \"punch\",\n                            args: [player.id, entity.id],\n                        },\n                        createWaitAction(2),\n                        {\n                            func: \"punch\",\n                            args: [player.id, entity.id],\n                        },\n                        createWaitAction(2),\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    game.actions.sipFrom = function (containerId) {\n        var container = game.getById(containerId);\n        for (var _i = 0, _a = game.getChildren(container).filter(function (e) { return e.fluid; }); _i < _a.length; _i++) {\n            var fluid = _a[_i];\n            if (fluid.turboTea) {\n                game.newLine(\"You feel like a 400 IQ, cupboard-opening, killing machine! In fact, you feel so good you feel like giving Gardens some feedback on their game!\");\n            }\n            else if (fluid.tea) {\n                game.newLine(\"It's not too bad. It's... fine.\");\n            }\n            else {\n                game.newLine(\"It's important to stay hydrated, I guess.\");\n            }\n        }\n    };\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) {\n                return fluidsIn(e);\n            }); _i < _a.length; _i++) {\n                var nonEmptyFluidContainer = _a[_i];\n                intents.push({\n                    representation: [\n                        game.word(\"sip from\"),\n                        nonEmptyFluidContainer,\n                    ],\n                    sequence: [\n                        createNewLineAction(\"You sip from the \" + nonEmptyFluidContainer.baseName + \".\"),\n                        createWaitAction(20),\n                        {\n                            func: \"sipFrom\",\n                            args: [nonEmptyFluidContainer.id],\n                        },\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    game.actions.readyClaws = function (targetId) {\n        var target = game.getById(targetId);\n        if (target.health === 5)\n            game.newLine(\"You let out a piercing shriek as you ready your razor-sharp, glassy claws!\");\n        else\n            game.newLine(\"You ready your claws again!\");\n    };\n    game.actions.claw = function (attackerId, targetId) {\n        var attacker = game.getById(attackerId);\n        var target = game.getById(targetId);\n        game.newLine(\"You tear out the \" + target.baseName + \"'s insides for 2 damage!\");\n        target.health -= 2;\n        game.emitSignal({\n            type: \"damageDealt\",\n            by: attacker,\n            to: target,\n            amount: 2,\n        });\n    };\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.health > 0; }); _i < _a.length; _i++) {\n                var target = _a[_i];\n                intents.push({\n                    representation: [\n                        game.word(\"attack\"),\n                        target,\n                        game.word(\"with claws\"),\n                    ],\n                    sequence: [\n                        { func: \"readyClaws\", args: [target.id] },\n                        createWaitAction(10),\n                        { func: \"claw\", args: [player.id, target.id] },\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    game.receivers.push({\n        on_damageDealt: function (data) {\n            game.newLine(\"Damage dealt by \" + data.by.baseName);\n            if (data.to.health <= 0 && !data.to.dead) {\n                data.to.dead = true;\n                game.newLine(\"You have defeated your first enemy, a vile \" + data.to.baseName + \". It drops a teabag!\");\n                data.to.baseName = \"dead \" + data.to.baseName;\n                data.health = undefined;\n                game.addEntity({\n                    baseName: \"VICTORIOUS teabag\",\n                    item: true,\n                    infusable: {\n                        flavour: \"VICTORY\",\n                    },\n                }, game.getParent(data.to));\n            }\n        },\n    });\n    game.receivers.push({\n        on_tick: function (data) {\n            var _loop_1 = function (stove) {\n                if (stove.active) {\n                    stove.ctr += 1;\n                    // put out a message regularly\n                    if (stove.ctr >= 2) {\n                        stove.ctr = 0;\n                        game.newLine(\"The stove's flame burns a warm orange.\");\n                    }\n                    var _loop_2 = function (containerOnStove) {\n                        // game.newLine(\n                        //     `The stove heats up the ${containerOnStove.baseName}`\n                        // );\n                        for (var _i = 0, _a = game.entities.filter(function (fluid) {\n                            return fluid.fluid &&\n                                game.isParent(containerOnStove, fluid);\n                        }); _i < _a.length; _i++) {\n                            var fluid = _a[_i];\n                            // game.newLine(\n                            //     `The stove heats up the ${fluid.baseName} in the ${containerOnStove.baseName}`\n                            // );\n                            fluid.temperature += 1;\n                            if (fluid.temperature == 23) {\n                                game.newLine(\"The \" + containerOnStove.baseName + \" is filled with hot \" + fluid.baseName + \"!\");\n                            }\n                        }\n                    };\n                    // heat up fluid inside containers on stove\n                    for (var _i = 0, _a = game.entities.filter(function (containerOnStove) {\n                        return containerOnStove.fluidContainer &&\n                            game.isParent(stove, containerOnStove);\n                    }); _i < _a.length; _i++) {\n                        var containerOnStove = _a[_i];\n                        _loop_2(containerOnStove);\n                    }\n                }\n            };\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.baseName === \"stove\"; }); _i < _a.length; _i++) {\n                var stove = _a[_i];\n                _loop_1(stove);\n            }\n        },\n    });\n    game.receivers.push({\n        on_tick: function (data) {\n            var _loop_3 = function (fluidContainer) {\n                for (var _i = 0, _a = game.entities.filter(function (hotFluid) {\n                    return hotFluid.fluid &&\n                        game.isParent(fluidContainer, hotFluid) &&\n                        hotFluid.temperature > 23;\n                }); _i < _a.length; _i++) {\n                    var hotFluid = _a[_i];\n                    var count = 0;\n                    var prefix = \"\";\n                    // if infusable in container and hot fluid\n                    for (var _b = 0, _c = game.entities.filter(function (e) { return e.infusable && game.isParent(fluidContainer, e); }); _b < _c.length; _b++) {\n                        var infusingTeabag = _c[_b];\n                        count += 1;\n                        prefix += infusingTeabag.infusable.flavour + \" \";\n                        game.emitSignal({ type: \"teaMade\" });\n                        if (count < 3) {\n                            hotFluid.baseName = prefix + \" tea\";\n                            hotFluid.tea = true;\n                        }\n                        else {\n                            hotFluid.baseName = \"TURBO TESTER TEA\";\n                            if (!hotFluid.turboTea) {\n                                hotFluid.turboTea = true;\n                                game.newLine(\"TOTAL VICTORY ACHIEVED! Enjoy your tea!\");\n                            }\n                        }\n                        // console.log(\"hotFluid\", hotFluid);\n                    }\n                }\n            };\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.fluidContainer; }); _i < _a.length; _i++) {\n                var fluidContainer = _a[_i];\n                _loop_3(fluidContainer);\n            }\n        },\n    });\n    game.addEntity({\n        baseName: \"winBehaviourState\",\n        invisible: true,\n        winBehaviorState: { won: false, uberWon: false },\n    });\n    game.receivers.push({\n        on_teaMade: function (data) {\n            var state = game.entities.filter(function (e) { return e.winBehaviorState; })[0];\n            if (state.winBehaviorState.won === false) {\n                game.newLine(\"Congratulations, you have made tea! Did you find all three teabags? I wonder what happens if you infuse them all at once...\");\n                state.winBehaviorState.won = true;\n            }\n        },\n    });\n    game.addEntity({\n        baseName: \"timer\",\n        invisible: true,\n        timer: { time: -1 },\n    });\n}\nmodule.exports = { loadMod: loadMod };\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ticks per second\nexports.tps = 6;\n// milliseconds per tick\nexports.mpt = 300;\nfunction s(nr) {\n    return exports.tps * nr;\n}\nexports.s = s;\nfunction m(nr) {\n    return exports.tps * nr * 60;\n}\nexports.m = m;\nfunction h(nr) {\n    return exports.tps * nr * 3600;\n}\nexports.h = h;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar GameModule = require(\"./GameModule\");\nvar PlayerModule = require(\"./PlayerModule\");\n// HACK\n// let newLine = utils.newLine;\n// import { newLine } from \"./utils\";\nvar game = new GameModule.Game();\nvar player = new PlayerModule.Player();\ngame.player = player;\n// load mods\nvar teaRoomMod = require(\"./modTeaRoom\");\nteaRoomMod.loadMod(player, game);\n// let debugMod = require(\"./modDebug\");\n// debugMod.loadMod(player, game);\nvar debug = false;\nvar area = game.addEntity({\n    baseName: \"tea room\",\n    area: true,\n});\ngame.addEntity(player, area);\nvar stove = game.addEntity({\n    baseName: \"stove\",\n    active: false,\n    surface: true,\n}, area);\nvar faucet = game.addEntity({\n    baseName: \"faucet\",\n    fluidSource: \"water\",\n}, area);\nvar punchingBag = game.addEntity({\n    baseName: \"punching bag\",\n    health: 5,\n}, area);\nvar teaCupboard = game.addEntity({\n    baseName: \"tea cupboard\",\n    solidContainer: true,\n    closed: true,\n}, area);\nvar cranberryTeabag = game.addEntity({\n    baseName: \"cranberry teabag\",\n    item: true,\n    infusable: {\n        flavour: \"OBVIOUS\",\n    },\n}, teaCupboard);\nvar table = game.addEntity({\n    baseName: \"table\",\n    surface: true,\n}, area);\nvar knife = game.addEntity({\n    baseName: \"knife\",\n    item: true,\n}, table, \"on\");\nvar cup = game.addEntity({\n    baseName: \"cup\",\n    item: true,\n    fluidContainer: true,\n}, table, \"on\");\nvar bowl = game.addEntity({\n    baseName: \"bowl\",\n    item: true,\n    fluidContainer: true,\n}, table, \"on\");\nvar note = game.addEntity({\n    baseName: \"super secret note\",\n    item: true,\n    readable: {\n        message: \"The note says: \\\"The password is 6...\",\n    },\n}, table, \"on\");\nvar lockedChest = game.addEntity({\n    baseName: \"locked chest\",\n    solidContainer: true,\n    closed: true,\n    item: true,\n    locked: { isLocked: true, password: \"6\" },\n}, table, \"on\");\nvar smallerChest = game.addEntity({\n    baseName: \"smaller chest\",\n    solidContainer: true,\n    closed: true,\n    item: true,\n}, lockedChest, \"in\");\nvar evenSmallerChest = game.addEntity({\n    baseName: \"even smaller chest\",\n    solidContainer: true,\n    closed: true,\n    item: true,\n}, smallerChest, \"in\");\nvar secretTeabag = game.addEntity({\n    baseName: \"secretive teabag\",\n    item: true,\n    infusable: { flavour: \"SECRET\" },\n}, smallerChest, \"in\");\nconsole.log(game.entities);\nconsole.log(\"comps of area\");\nvar keys = \"abcdefghijklmnopqrstuwxyz\".split(\"\");\ndocument.addEventListener(\"keypress\", function (event) {\n    var name = event.key;\n    if (name === \"`\") {\n        game.playRandomly = !game.playRandomly;\n    }\n    if (player.picking && keys.indexOf(name) !== -1) {\n        // alert(`pressed ${keys.indexOf(name)} of ${keys}`)\n        player.pickNextWord(keys.indexOf(name));\n        player.setOptionsUI();\n    }\n}, false);\nplayer.updateCommandUI();\ngame.updateEntityTreeUI();\ngame.getIntents();\nconsole.log({ \"all intents\": player.getAllIntents() });\n// for (let intent of player.getAllIntents()) {\n//     console.log({ intent })\n// }\nfunction debugText(text) {\n    document.getElementById(\"debug\").innerText = text;\n}\n"],"names":[],"sourceRoot":""}