{"version":3,"file":"./dist/bundle.js","mappings":";;;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA,aAAa,mBAAO,CAAC,iCAAU;AAC/B,sBAAsB,mBAAO,CAAC,+CAAiB;AAC/C,iBAAiB,mBAAO,CAAC,qCAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,6DAA6D,IAAI;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,4CAA4C;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,mCAAmC;AACnC,mCAAmC;AACnC;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB,GAAG,gBAAgB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,gBAAgB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAgE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,gCAAgC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,qBAAqB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,gBAAgB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,2DAA2D,kBAAkB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA,oDAAoD,cAAc;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA,kEAAkE,iBAAiB,GAAG,gBAAgB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW,cAAc,GAAG;AAC1D,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAK,IAAI,CAAqD;AAClF,oBAAoB,MAAK,IAAI,CAAqC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8BAA8B,GAAG,gBAAgB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,kEAAkE,iCAAiC,GAAG,gBAAgB;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,YAAY;AACZ;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,oBAAoB,sBAAsB;AAC1C,qBAAqB,aAAa;AAClC;AACA;;;;;;;;;;;ACnlBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB,4BAA4B,8BAA8B;AACzG,wDAAwD,4BAA4B;AACpF;AACA;AACA;AACA,+BAA+B,sCAAsC;AACrE;AACA;AACA;AACA;AACA,sDAAsD,uBAAuB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,0DAA0D,GAAG,gBAAgB;AACzI;AACA,0BAA0B,uCAAuC;AACjE;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA,CAAC;AACD,cAAc;;;;;;;;;;;AC5LD;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,2BAA2B;AAChF;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA,CAAC;AACD,qBAAqB;;;;;;;;;;;ACtBR;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA,iCAAiC;AACjC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;;;;;;;;;;ACXT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,iCAAU;AAC/B;AACA,qDAAqD,kBAAkB;AACvE;AACA,+CAA+C,MAAM;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sEAAsE,iDAAiD,GAAG,gBAAgB;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAA8C;AACxE;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C,qBAAqB,yBAAyB;AAC9C,qBAAqB,yBAAyB;AAC9C,wBAAwB,2BAA2B;AACnD,qBAAqB,oCAAoC;AACzD,qBAAqB,kCAAkC;AACvD,qBAAqB,kCAAkC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,sEAAsE,iBAAiB,GAAG,gBAAgB;AAC1G;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,eAAe;AACf,mBAAmB;;;;;;;;;;;AClON;AACb;AACA,kDAAkD,QAAQ;AAC1D,yCAAyC,QAAQ;AACjD,yDAAyD,QAAQ;AACjE;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA,aAAa,wBAAwB;AACrC;AACA;AACA,qDAAqD,kBAAkB;AACvE,mDAAmD,gBAAgB;AACnE;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,WAAW,6CAA6C;AAC7E,qBAAqB,WAAW,2CAA2C;AAC3E;AACA,aAAa,WAAW,8CAA8C;AACtE;AACA;AACA;AACA;AACA,aAAa,WAAW,8CAA8C;AACtE;AACA;AACA;AACA,iCAAiC,eAAe;AAChD,qBAAqB,WAAW,8CAA8C;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4BAA4B,GAAG,gBAAgB;AACtF;AACA;AACA;AACA;AACA,qEAAqE,kBAAkB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,sCAAsC,uCAAuC;AAC7E;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kDAAkD;AACzF;AACA,SAAS;AACT,KAAK;AACL;AACA,eAAe;;;;;;;;;;;AClHF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;;;;;;;UCjBT;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,mBAAO,CAAC,yCAAc;AACvC,mBAAmB,mBAAO,CAAC,6CAAgB;AAC3C,eAAe,mBAAO,CAAC,qCAAY;AACnC,kBAAkB,mBAAO,CAAC,2CAAe;AACzC;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA,iBAAiB,WAAW,6CAA6C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB,KAAK,KAAK;AAC1D;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,cAAc,uCAAuC;AACrD;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA","sources":["webpack://starspawn/./src/GameModule.ts","webpack://starspawn/./src/PlayerModule.ts","webpack://starspawn/./src/PriorityQueue.ts","webpack://starspawn/./src/TextNode.ts","webpack://starspawn/./src/modDebug.ts","webpack://starspawn/./src/modFighting.ts","webpack://starspawn/./src/timing.ts","webpack://starspawn/webpack/bootstrap","webpack://starspawn/./src/index.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// let utils = require(\"./utils\")\n// let timing = require(\"./timing\");\nvar timing = require(\"./timing\");\nvar PriorityQueue_1 = require(\"./PriorityQueue\");\nvar TextNode_1 = require(\"./TextNode\");\nvar Game = /** @class */ (function () {\n    function Game() {\n        this.id = 0;\n        this.entities = [];\n        this.words = {};\n        this.logId = 0;\n        this.history = {};\n        this.log = {};\n        this.intentsReady = true;\n        this.queue = []; // [Action*]\n        this.queueSpliceI = 0;\n        this.handlers = new PriorityQueue_1.PriorityQueue(); // {on_eventType:func()}\n        this.time = 0;\n        this.player = null;\n        this.playRandomly = false;\n        this.actions = {};\n    }\n    Game.prototype.addEntity = function (entity, parentEntity, rel) {\n        if (parentEntity === void 0) { parentEntity = null; }\n        if (rel === void 0) { rel = null; }\n        this.entities.push(entity);\n        entity.id = this.id;\n        this.id += 1;\n        if (parentEntity !== null) {\n            this.setParent(parentEntity, entity, rel);\n        }\n        return entity;\n    };\n    Game.prototype.getById = function (id) {\n        var found = undefined;\n        for (var i = 0; i < this.entities.length; i++) {\n            if (this.entities[i].id === id) {\n                found = this.entities[i];\n            }\n        }\n        if (found === undefined)\n            throw \"object not found with id \" + id;\n        return found;\n    };\n    Game.prototype.getDepth = function (entity) {\n        var depth = 0;\n        while (this.getParent(entity) !== undefined) {\n            entity = this.getParent(entity);\n            depth += 1;\n        }\n        return depth;\n    };\n    Game.prototype.addHandler = function (value, handler) {\n        this.handlers.enqueue({ value: value, element: handler });\n        return handler;\n    };\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // ENTITY LOOKUP\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    Game.prototype.intentless = function () {\n        return this.entities.filter(function (e) { return e.actor && e.actor.intent === null; });\n    };\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // QUALITY\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    Game.prototype.getTotalQuality = function (entityId, qualityName) {\n        var acceptableLinks = [\"activeItem\", \"attachment\"];\n        var game = this;\n        function getQualitySubtree(entityId, baseQ, addQ, mulQ) {\n            if (baseQ === void 0) { baseQ = 0; }\n            if (addQ === void 0) { addQ = 0; }\n            if (mulQ === void 0) { mulQ = 1; }\n            var entity = game.getById(entityId);\n            // check qualities\n            for (var _i = 0, _a = game\n                .getChildren(entity)\n                .filter(function (q) { return q.quality; }); _i < _a.length; _i++) {\n                var quality = _a[_i];\n                if (quality.quality.name === qualityName) {\n                    baseQ = quality.quality.value;\n                }\n                else if (quality.quality.name === \"add\" + qualityName) {\n                    addQ += quality.quality.value;\n                }\n                else if (quality.quality.name === \"mul\" + qualityName) {\n                    mulQ *= quality.quality.value;\n                }\n            }\n            for (var _b = 0, _c = game.getChildren(entity); _b < _c.length; _b++) {\n                var child = _c[_b];\n                // if acceptable link\n                if (acceptableLinks.indexOf(child.rel) != -1) {\n                    var subtree = getQualitySubtree(child.id, baseQ, addQ, mulQ);\n                    baseQ = subtree.baseQ;\n                    addQ += subtree.addQ;\n                    mulQ *= subtree.mulQ;\n                }\n            }\n            return {\n                baseQ: baseQ,\n                addQ: addQ,\n                mulQ: mulQ,\n            };\n        }\n        var pack = getQualitySubtree(entityId);\n        var baseQ = pack.baseQ, addQ = pack.addQ, mulQ = pack.mulQ;\n        console.log({ qualityName: qualityName, baseQ: baseQ, addQ: addQ, mulQ: mulQ });\n        return (baseQ + addQ) * mulQ;\n    };\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // PARENT\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    Game.prototype.setParent = function (parentEntity, childEntity, rel) {\n        if (rel === void 0) { rel = null; }\n        if (parentEntity === undefined ||\n            parentEntity.id === undefined ||\n            this.getById(parentEntity.id) === undefined)\n            throw \"Undefined parent.\";\n        this.unsetParent(childEntity);\n        childEntity.parent = parentEntity.id;\n        if (rel !== null) {\n            childEntity.rel = rel;\n        }\n    };\n    Game.prototype.setParentById = function (parentId, childId, rel) {\n        if (rel === void 0) { rel = null; }\n        this.setParent(this.getById(parentId), this.getById(childId), rel);\n    };\n    Game.prototype.unsetParent = function (childEntity) {\n        childEntity.parent = undefined;\n    };\n    Game.prototype.isParent = function (parentEntity, childEntity) {\n        return parentEntity.id === childEntity.parent;\n    };\n    Game.prototype.getParent = function (childEntity) {\n        var parent = childEntity.parent === undefined\n            ? undefined\n            : this.getById(childEntity.parent);\n        return parent;\n    };\n    Game.prototype.getChildren = function (entity) {\n        // console.log(\"loop\", entity.id);\n        var contents = this.entities.filter(function (e) { return e.parent === entity.id; });\n        // let contents = this.entities.filter((e) => this.isParent(entity, e));\n        return contents;\n    };\n    Game.prototype.getChildrenById = function (id) {\n        return this.getChildren(this.getById(id));\n    };\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    Game.prototype.deleteById = function (id) {\n        // TODO? throw if not found\n        this.entities = this.entities.filter(function (e) { return e.id !== id; });\n    };\n    Game.prototype.isAccessible = function (entity) {\n        if (entity === undefined || this.getParent(entity) === undefined)\n            return true;\n        var parent = this.getParent(entity);\n        var accessible = (parent.closed === false || parent.closed === undefined) &&\n            (parent.locked === undefined || parent.locked.isLocked === false);\n        return accessible && this.isAccessible(parent);\n    };\n    Game.prototype.enqueue = function (action, splice) {\n        if (splice === void 0) { splice = true; }\n        if (!splice) {\n            this.queue.push(action);\n        }\n        else {\n            this.queue.splice(this.queueSpliceI, 0, action);\n            this.queueSpliceI++;\n        }\n    };\n    Game.prototype.emitEvent = function (data) {\n        var responses = [];\n        for (var _i = 0, _a = this.handlers.asArray(); _i < _a.length; _i++) {\n            var handler = _a[_i];\n            if (handler[\"on_\" + data.type]) {\n                responses.push(handler[\"on_\" + data.type](data));\n            }\n        }\n        console.log(\"emitting\");\n        console.log({ data: data });\n        return responses;\n    };\n    Game.prototype.queueEvent = function (data) {\n        this.enqueue({ events: [data] });\n    };\n    // called when action is first started\n    Game.prototype.processAction = function (action, actor) {\n        if (action.maxDuration === undefined) {\n            action.maxDuration = action.duration || 0;\n            this.logId += 1;\n            // set properties and insert to history\n            action.id = this.logId;\n            this.history[action.id] = action;\n            action.actor = actor.id;\n            // update logItem\n            this.updateLogItem(action.id);\n        }\n        return action;\n    };\n    Game.prototype.updateLogItem = function (logId) {\n        // hack; update for text nodes\n        var playerId = this.entities.filter(function (e) { return e.player; })[0].id;\n        // if no action at id, leave alone\n        if (!this.history[logId]) {\n            return;\n        }\n        else {\n            // no log, has action\n            var action = this.history[logId];\n            // compute sticky and progressBar\n            var sticky = void 0, progressBar = void 0;\n            var inProgress = false;\n            if (action.duration && action.duration >= 0) {\n                inProgress = true;\n                progressBar = \"[\" + (\"=\".repeat(action.maxDuration - action.duration) +\n                    \"-\".repeat(action.duration)) + \"]\";\n                sticky = true;\n            }\n            else {\n                if (action.maxDuration > 0) {\n                    progressBar = \"[\" + \"X\".repeat(action.maxDuration) + \"]\";\n                }\n                else {\n                    progressBar = \"\";\n                }\n                sticky = false;\n            }\n            this.log[logId] = {\n                id: logId,\n                textNodes: [\n                    TextNode_1.createTextNode(inProgress && action.processText\n                        ? action.processText\n                        : \"\"),\n                ],\n                sticky: sticky,\n                progressBar: progressBar,\n                alignLeft: playerId === action.actor,\n            };\n        }\n    };\n    Game.prototype.updateLog = function () {\n        // clear display\n        var display = document.getElementById(\"display\");\n        display.innerText = \"\";\n        for (var i = 0; i <= this.logId; i++) {\n            this.updateLogItem(i);\n            // update UI at i\n            if (this.log[i]) {\n                var logItem = this.log[i];\n                var node = document.createElement(\"div\");\n                node.id = \"logItem\" + logItem.id;\n                for (var _i = 0, _a = logItem.textNodes; _i < _a.length; _i++) {\n                    var textNode = _a[_i];\n                    var textBit = document.createElement(\"span\");\n                    // do not change it\n                    // it is cursed\n                    // if you want to change things\n                    // change them elsewhere\n                    if (textNode.foreground) {\n                        textBit.style.color = textNode.foreground;\n                    }\n                    if (textNode.background) {\n                        textBit.style.backgroundColor = textNode.background;\n                    }\n                    display.appendChild(textBit);\n                    textBit.innerText = \"\" + textNode.text;\n                    console.log(textBit.style);\n                    console.log(textBit);\n                    // textBit.style = \"color: #c02537 !important;\";\n                    // node.appendChild(textBit);\n                    // node.innerHTML +=\n                    // `<br>` +\n                    // `<a style=\"background:red\">${textNode.text}</a>`;\n                }\n                node.innerText += \"\\n\" + logItem.progressBar;\n                node.style.textAlign = logItem.alignLeft ? \"left\" : \"right\";\n                display.appendChild(node);\n                display.scrollTop = display.scrollHeight;\n            }\n        }\n    };\n    Game.prototype.newLine = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this.logId += 1;\n        var textNodes = [];\n        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n            var arg = args_1[_a];\n            if (typeof arg === \"string\") {\n                var defaultTextNode = {\n                    // background: \"cyan\",\n                    // foreground: \"--offblack\",\n                    text: arg,\n                };\n                textNodes.push(defaultTextNode);\n            }\n            else {\n                textNodes.push(arg);\n            }\n        }\n        var logItem = {\n            textNodes: textNodes,\n            id: this.logId,\n            alignLeft: true,\n            sticky: false,\n            progressBar: \"\",\n        };\n        this.log[this.logId] = logItem;\n        return logItem;\n    };\n    Game.prototype.getPlayerIntent = function () {\n        var _this = this;\n        if (this.player) {\n            if (!this.player.actor.intent) {\n                // lay out options if necessary\n                if (!this.player.picking) {\n                    this.player.picking = true;\n                    this.player.setOptionsUI();\n                }\n                if (this.playRandomly) {\n                    // pick random word and call this function again\n                    setTimeout(function () {\n                        var options = _this.player.getNextWords();\n                        // avoid cancelling actions if not on first word\n                        if (_this.player.command.length > 0) {\n                            _this.player.pickNextWord(Math.floor(Math.random() * (options.length - 1)));\n                        }\n                        else {\n                            // pick any first word\n                            _this.player.pickNextWord(Math.floor(Math.random() * options.length));\n                        }\n                        _this.getPlayerIntent();\n                    }, 100);\n                }\n                else {\n                    // hang for manual pick\n                    setTimeout(function () {\n                        _this.getPlayerIntent();\n                    }, 100);\n                }\n            }\n            else {\n                // player intent done, move on to NPCs\n                this.getNPCIntents();\n            }\n        }\n    };\n    Game.prototype.getNPCIntents = function () {\n        this.emitEvent({ type: \"getIntents\" });\n        this.processIntents();\n    };\n    Game.prototype.processIntents = function () {\n        // get this tick's Actions {aedpcs} for every entity with intent (null or Intent)\n        this.intentsReady = true;\n        for (var _i = 0, _a = this.entities.filter(function (e) { return e.actor; }); _i < _a.length; _i++) {\n            var entity = _a[_i];\n            var intent = entity.actor.intent;\n            // empty intent\n            if (!intent) {\n                this.intentsReady = false;\n                throw \"entity without intent \" + entity.name;\n                // hang and reset for player input\n            }\n            else if (intent && intent.sequence.length > 0) {\n                // extract actions and enqueue them\n                var ticks = 0;\n                // extract actions until we go over 1 tick\n                while (ticks === 0 && intent.sequence.length > 0) {\n                    // process and enqueue action\n                    intent.sequence[0] = this.processAction(intent.sequence[0], entity);\n                    var action = intent.sequence[0];\n                    this.enqueue(action, false);\n                    // // propagate events\n                    // if (action.events) {\n                    //     for (let event of action.events) {\n                    //         this.queueEvent(event);\n                    //     }\n                    // }\n                    // queue up actions including the first with duration\n                    if (action.duration <= 0 || action.duration === undefined) {\n                        // instant action, keep queueSplicing\n                        intent.sequence.splice(0, 1);\n                    }\n                    else if (action.duration <= 1) {\n                        // end actions here\n                        intent.sequence.splice(0, 1);\n                        action.duration -= 1;\n                        ticks = action.duration;\n                    }\n                    else {\n                        // action that will be taken multiple times\n                        action.duration -= 1;\n                        ticks = action.duration;\n                    }\n                }\n                // if the last action was extracted, render null\n                if (intent.sequence.length === 0) {\n                    entity.actor.intent = null;\n                }\n            }\n        }\n        // when ready, propagate events\n        if (this.intentsReady) {\n            // queue up a tick event\n            this.queue.push({ events: [{ type: \"tick\" }] });\n            // newLine(`starting tick ${game.time}`);\n            this.processNext();\n        }\n    };\n    Game.prototype.processNext = function () {\n        var _this = this;\n        // get next action to execute\n        if (this.queue.length > 0) {\n            this.queueSpliceI = 0;\n            var action = this.queue.shift();\n            // func: execute command\n            if (action.func) {\n                if (this.actions[action.func]) {\n                    var func = this.actions[action.func];\n                    if (action.args) {\n                        func.apply(void 0, action.args);\n                    }\n                    else {\n                        func();\n                    }\n                }\n                else {\n                    throw \"Unknown action \" + action.func + \", args \" + action.args;\n                }\n            }\n            // events: propagate events\n            if (action.events && action.events.length > 0) {\n                for (var _i = 0, _a = action.events; _i < _a.length; _i++) {\n                    var event_1 = _a[_i];\n                    // new event to propagate\n                    var type = event_1.type;\n                    // send to every handler\n                    var responses = this.emitEvent(event_1);\n                    // TODO: blocking and response collection\n                    false && console.log({ event: event_1, i: this.queueSpliceI });\n                    false && console.log({ responses: responses });\n                }\n            }\n            // pause: execute the next instantly or with pause\n            this.updateUI();\n            if (action.pause) {\n                setTimeout(function () {\n                    _this.processNext();\n                }, action.pause);\n            }\n            else {\n                this.processNext();\n            }\n        }\n        else {\n            // loop again\n            this.time += 1;\n            this.getPlayerIntent();\n        }\n    };\n    Game.prototype.word = function (text) {\n        if (!this.words[text]) {\n            var word = { type: \"word\", name: text };\n            this.words[text] = word;\n        }\n        return this.words[text];\n    };\n    Game.prototype.updateUI = function () {\n        this.updateEntityTreeUI();\n        this.updateClockUI();\n        this.updateLog();\n    };\n    Game.prototype.updateEntityTreeUI = function () {\n        var _this = this;\n        // time\n        var ticks = this.time % timing.tps;\n        var hours = Math.floor(this.time / timing.tps / 3600);\n        var minutes = Math.floor(this.time / timing.tps / 60);\n        var seconds = Math.floor(this.time / timing.tps);\n        var game = this;\n        var treeNode = document.getElementById(\"entityTree\");\n        treeNode.innerHTML = \"Time: \" + hours + \":\" + minutes + \":\" + seconds + \":\" + ticks + \"\\n\\n</br>\";\n        // subtree\n        function indentedSubtree(entity, depth) {\n            if (depth === void 0) { depth = 0; }\n            if ((!entity.name && !entity.quality) || entity.invisible)\n                return null;\n            // base text and focus\n            var text = \"\";\n            var focusedText = game.player.focus === entity.id ? \"(focused)\" : \"\";\n            // object or quality\n            if (entity.quality) {\n                text = \"Q: \" + entity.quality.name + \" \" + entity.quality.value;\n            }\n            else if (entity.name) {\n                text = \"\" + entity.name;\n            }\n            // assemble text chunk\n            var textNode = document.createElement(\"span\");\n            textNode.innerText = \"|\" + \"----\".repeat(depth) + \" \" + text + \" \" + focusedText + \"\\n\";\n            textNode.className = \"treeObject\";\n            if (game.getChildren(entity).length > 0) {\n                for (var _i = 0, _a = game\n                    .getChildren(entity)\n                    .filter(function (e) { return game.isAccessible(e); }); _i < _a.length; _i++) {\n                    var child = _a[_i];\n                    var subtree = indentedSubtree(child, depth + 1);\n                    if (subtree !== null)\n                        textNode.appendChild(subtree);\n                }\n            }\n            // on click, focus action\n            textNode.addEventListener(\"click\", function (e) {\n                e = window.event || e;\n                if (this === e.target) {\n                    if (game.player.focus === entity.id) {\n                        game.player.focus = null;\n                    }\n                    else {\n                        game.player.focus = entity.id;\n                    }\n                    game.player.command = [];\n                    game.player.setOptionsUI();\n                }\n                game.updateEntityTreeUI();\n            });\n            return textNode;\n        }\n        for (var _i = 0, _a = this.entities.filter(function (e) { return _this.getDepth(e) === 0; }); _i < _a.length; _i++) {\n            var entity = _a[_i];\n            var subtree = indentedSubtree(entity, 0);\n            if (subtree) {\n                treeNode.appendChild(subtree);\n            }\n        }\n    };\n    Game.prototype.updateClockUI = function () {\n        var clock = document.getElementById(\"clock\");\n        var ctx = clock.getContext(\"2d\");\n        var width = clock.clientWidth;\n        var height = clock.clientHeight;\n        // ctx.stroke = \"white\";\n        ctx.clearRect(0, 0, width, height);\n        ctx.fillText(\"\" + this.time, width / 2 - 6, height / 2 + 5);\n        // dots\n        ctx.save();\n        ctx.translate(width / 2, height / 2);\n        ctx.beginPath();\n        ctx.rotate(-Math.PI / 2);\n        for (var i = 0; i < 12; i++) {\n            ctx.moveTo(20, 0);\n            ctx.lineTo(25, 0);\n            ctx.rotate((2 * Math.PI) / 12);\n        }\n        ctx.stroke();\n        ctx.restore();\n        // ticks\n        ctx.save();\n        ctx.translate(width / 2, height / 2);\n        ctx.beginPath();\n        ctx.rotate(-Math.PI / 2);\n        ctx.rotate((2 * Math.PI * this.time) / timing.tps);\n        ctx.arc(10, 0, 2, 0, 2 * Math.PI);\n        ctx.stroke();\n        ctx.restore();\n        // seconds\n        // ticks\n        ctx.save();\n        ctx.translate(width / 2, height / 2);\n        ctx.beginPath();\n        ctx.rotate(-Math.PI / 2);\n        ctx.rotate((2 * Math.PI * this.time) / timing.tps / 60);\n        ctx.moveTo(10, 0);\n        ctx.lineTo(25, 0);\n        ctx.stroke();\n        ctx.restore();\n    };\n    return Game;\n}());\nexports.Game = Game;\n// let g = new Game();\n// let teapot = g.buildObject(\n//     {\n//         teapot: true,\n//     },\n//     [\n//         [\"is\", { fluidContainer: true }],\n//         [\"has\", { spout: true }],\n//     ]\n// );\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Player = /** @class */ (function () {\n    function Player() {\n        this.parent = undefined;\n        this.name = \"player\";\n        this.player = true;\n        this.actor = {\n            intent: null,\n        };\n        this.picking = false;\n        this.command = [];\n        this.patterns = [];\n        this.focus = null;\n        this.id = -1;\n    }\n    Player.prototype.addPattern = function (pattern) {\n        this.patterns.push(pattern);\n    };\n    Player.prototype.getAllIntents = function () {\n        var intents = [];\n        for (var _i = 0, _a = this.patterns; _i < _a.length; _i++) {\n            var pattern = _a[_i];\n            for (var _b = 0, _c = pattern.intents(); _b < _c.length; _b++) {\n                var intent = _c[_b];\n                intents.push(intent);\n            }\n        }\n        return intents;\n    };\n    //^ getAllIntents(), command\n    Player.prototype.getValidIntents = function () {\n        // get remaining Intents that match the command and focus so far\n        var validIntents = [];\n        for (var _i = 0, _a = this.getAllIntents(); _i < _a.length; _i++) {\n            var intent = _a[_i];\n            // check intent for command validity\n            var cmdValid = true;\n            for (var i = 0; i < this.command.length; i++) {\n                if (intent.representation[i] !== this.command[i]) {\n                    cmdValid = false;\n                }\n            }\n            // check intent for focus validity, if any focus\n            var focusValid = this.focus ? false : true;\n            for (var _b = 0, _c = intent.representation; _b < _c.length; _b++) {\n                var entity = _c[_b];\n                if (entity.id === this.focus) {\n                    focusValid = true;\n                }\n            }\n            if (cmdValid && focusValid) {\n                validIntents.push(intent);\n            }\n        }\n        return validIntents;\n    };\n    //^ getValidIntents(), command\n    // get options for next word to pick\n    Player.prototype.getNextWords = function () {\n        var options = [];\n        var validIntents = this.getValidIntents();\n        // console.log(`${validIntents.length} valid commands at command ${this.command.map(w => w.name)}`)\n        for (var _i = 0, validIntents_1 = validIntents; _i < validIntents_1.length; _i++) {\n            var intent = validIntents_1[_i];\n            // if the intent is the same length as the command, it can be confirmed\n            if (intent.representation.length == this.command.length) {\n                options.push({ name: \"> confirm <\", type: \"confirm\" });\n            }\n            else {\n                var newOption = intent.representation[this.command.length];\n                var duplicateThing = false;\n                for (var _a = 0, options_1 = options; _a < options_1.length; _a++) {\n                    var option = options_1[_a];\n                    if (newOption === option) {\n                        duplicateThing = true;\n                    }\n                }\n                if (!duplicateThing) {\n                    options.push(newOption);\n                }\n            }\n        }\n        if (this.command.length > 0) {\n            options.push({ name: \"> cancel <\", type: \"cancel\" });\n        }\n        return options;\n    };\n    //^ updateCommandUI()\n    Player.prototype.pickNextWord = function (optionI) {\n        var options = this.getNextWords();\n        if (options[optionI].type === \"confirm\") {\n            this.setIntent();\n        }\n        else if (options[optionI].type === \"cancel\") {\n            this.command = [];\n            this.focus = null;\n        }\n        else {\n            this.command.push(options[optionI]);\n        }\n        this.updateCommandUI();\n    };\n    // getValidIntents(), clearCommand()\n    // set intent and clear the command\n    Player.prototype.setIntent = function () {\n        var _this = this;\n        // get valid intents\n        var intents = this.getValidIntents();\n        // from intents of command's length\n        for (var _i = 0, _a = intents.filter(function (i) { return i.representation.length === _this.command.length; }); _i < _a.length; _i++) {\n            var intent = _a[_i];\n            console.log({ intent: intent, command: this.command });\n            var valid = true;\n            for (var i = 0; i < intent.representation.length; i++) {\n                if (intent.representation[i] !== this.command[i]) {\n                    console.log(\"execution wonk, not one valid action\");\n                    valid = false;\n                }\n            }\n            if (valid) {\n                // set intent, not picking\n                this.actor.intent = intent;\n                // intent.totalDuration = intent.sequence.reduce(\n                //     (sum, action) => sum + action.duration || 0,\n                //     0\n                // );\n                // intent.elapsed = 0;\n                // console.log({ intent });\n                this.picking = false;\n                this.focus = null;\n                // clear command\n                this.command = [];\n                this.updateCommandUI();\n                return;\n            }\n        }\n    };\n    Player.prototype.updateCommandUI = function () {\n        document.getElementById(\"command\").innerHTML =\n            \">\" + this.command.map(function (e) { return e.name; }).join(\" \");\n    };\n    Player.prototype.clearOptionsUI = function () {\n        document.getElementById(\"options\").innerHTML = \"\";\n    };\n    Player.prototype.setOptionsUI = function () {\n        var _this = this;\n        document.getElementById(\"options\").innerHTML = \"\";\n        if (!this.picking)\n            return;\n        // get the next words, and create an element for each on document\n        var options = this.getNextWords();\n        var keys = \"abcdefghijklmnopqrstuwxyz\".split(\"\");\n        var _loop_1 = function (i) {\n            var optionText = options[i].name;\n            // create a span with the optionText name\n            shortcutNode = document.createElement(\"a\");\n            // shortcutNode.style.color = \"lightgrey\";\n            shortcutNode.innerText = keys[i] + \") \";\n            // keyboard shortcutNode\n            optionNode = document.createElement(\"a\");\n            // optionNode.style.color = \"white\";\n            optionNode.innerText = optionText;\n            shortcutNode.appendChild(optionNode);\n            document.getElementById(\"options\").appendChild(shortcutNode);\n            // when the span is clicked, handle using that optionText\n            // REFACTOR: bad\n            shortcutNode.addEventListener(\"click\", function () {\n                _this.pickNextWord(i);\n                _this.setOptionsUI();\n            });\n            if (options[i].type === \"confirm\") {\n                shortcutNode.className = \"confirm\";\n            }\n            else if (options[i].type === \"cancel\") {\n                shortcutNode.className = \"cancel\";\n            }\n            else {\n                shortcutNode.className = \"choice\";\n            }\n        };\n        var shortcutNode, optionNode;\n        for (var i = 0; i < options.length; i++) {\n            _loop_1(i);\n        }\n    };\n    return Player;\n}());\nexports.Player = Player;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PriorityQueue = /** @class */ (function () {\n    function PriorityQueue() {\n        this.list = [];\n    }\n    PriorityQueue.prototype.enqueue = function (element) {\n        this.list.push(element);\n        this.reorganise();\n        return element;\n    };\n    PriorityQueue.prototype.reorganise = function () {\n        this.list = this.list.sort(function (a, b) { return a.value - b.value; });\n    };\n    PriorityQueue.prototype.getAt = function (i) {\n        return this.list[i].element;\n    };\n    PriorityQueue.prototype.asArray = function () {\n        return this.list.map(function (pqe) { return pqe.element; });\n    };\n    return PriorityQueue;\n}());\nexports.PriorityQueue = PriorityQueue;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction createTextNode(text, background, foreground) {\n    if (background === void 0) { background = null; }\n    if (foreground === void 0) { foreground = null; }\n    return {\n        text: text,\n        background: background,\n        foreground: foreground,\n    };\n}\nexports.createTextNode = createTextNode;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar timing = require(\"./timing\");\nfunction loadMod(game) {\n    var player = game.entities.filter(function (e) { return e.player; })[0];\n    game.actions.wait = function (ticks) {\n        // game.newLine(`Still waiting... of ${ticks}`);\n    };\n    function createNewLineAction(text) {\n        return {\n            func: \"newLine\",\n            args: [text],\n        };\n    }\n    function createWaitAction(ticks) {\n        return {\n            func: \"wait\",\n            args: [ticks],\n            duration: ticks,\n            // 1 -> 1, 10 -> 2\n            pause: timing.mpt / Math.pow(ticks, 1),\n        };\n    }\n    game.actions.traverse = function (actorId, pathId) {\n        var path = game.getById(pathId);\n        var origin = game.getById(path.path.from);\n        var destination = game.getById(path.path.to);\n        var actor = game.getById(actorId);\n        if (actor.player) {\n            game.newLine(\"You go to \" + destination.name);\n        }\n        game.queueEvent({\n            type: \"traverse\",\n        });\n        actor.parent = destination.id;\n    };\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.path && e.path.from === player.parent; }); _i < _a.length; _i++) {\n                var path = _a[_i];\n                intents.push({\n                    representation: [\n                        game.word(\"go:\"),\n                        game.getById(path.path.to),\n                    ],\n                    sequence: [\n                        createWaitAction(path.path.distance),\n                        { func: \"traverse\", args: [player.id, path.id] },\n                    ],\n                });\n            }\n            return intents;\n        },\n    });\n    // // wait various durations\n    // player.patterns.push({\n    //     intents: () => {\n    //         let intents = [];\n    //         let durations = [\n    //             { name: \"1 tick\", dur: 1 },\n    //             { name: \"3 ticks\", dur: 3 },\n    //             { name: \"6 ticks\", dur: 6 },\n    //             // { name: \"12 ticks\", dur: 12 },\n    //             { name: \"1 minute\", dur: timing.m(1) },\n    //             { name: \"1 hour\", dur: timing.h(1) },\n    //             { name: \"1 day\", dur: timing.h(24) },\n    //         ];\n    //         for (let duration of durations) {\n    //             let intent = {\n    //                 representation: [\n    //                     game.word(\"wait\"),\n    //                     game.word(duration.name),\n    //                 ],\n    //                 sequence: [\n    //                     createNewLineAction(`You wait ${duration.dur} ticks.`),\n    //                     createWaitAction(duration.dur),\n    //                 ],\n    //             };\n    //             intents.push(intent);\n    //         }\n    //         return intents;\n    //     },\n    // });\n    // random clapping\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            // the effect function\n            function effect() {\n                game.newLine(\"CLAP!\");\n            }\n            // the sequence\n            intents.push({\n                representation: [game.word(\"DEBUG\"), game.word(\"slow clap.\")],\n                sequence: [\n                    createWaitAction(4),\n                    createNewLineAction(\"CLAP!\"),\n                    createWaitAction(2),\n                    createNewLineAction(\"CLAP!\"),\n                    createNewLineAction(\"CLAP!\"),\n                    createWaitAction(2),\n                    createNewLineAction(\"CLAP!\"),\n                    createNewLineAction(\"CLAP!\"),\n                    createNewLineAction(\"CLAP!\"),\n                ],\n            });\n            return intents;\n        },\n    });\n    function createPingAction() {\n        return {\n            func: \"newLine\",\n            args: [\"ping\"],\n            pause: 100,\n            events: [{ type: \"ping\" }],\n            duration: 0,\n        };\n    }\n    // 3x ping, to be responded to with pong and peng\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            intents.push({\n                representation: [game.word(\"DEBUG\"), game.word(\"3 x ping.\")],\n                sequence: [\n                    createPingAction(),\n                    createPingAction(),\n                    createPingAction(),\n                ],\n            });\n            return intents;\n        },\n    });\n    game.addHandler(100, {\n        on_ping: function (data) {\n            game.enqueue({\n                func: \"newLine\",\n                args: [\"Pong!\"],\n                events: [{ type: \"pong\" }],\n                pause: 300,\n            });\n        },\n    });\n    game.addHandler(99, {\n        on_pong: function (data) {\n            game.enqueue({\n                func: \"newLine\",\n                args: [\"Peng!\"],\n                events: [{ type: \"peng\" }],\n                pause: 300,\n            });\n        },\n    });\n    // plain longer action\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            // the sequence\n            intents.push({\n                representation: [\n                    game.word(\"DEBUG\"),\n                    game.word(\"POW\"),\n                    game.word(\"POW\"),\n                    game.word(\"POW\"),\n                ],\n                sequence: [createNewLineAction(\"POW POW POW!\")],\n            });\n            return intents;\n        },\n    });\n    // plain shorter action\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            // the sequence\n            intents.push({\n                representation: [game.word(\"DEBUG\"), game.word(\"POW\")],\n                sequence: [createNewLineAction(\"POW!\")],\n            });\n            return intents;\n        },\n    });\n    // duration 2 action that releases pings\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            // the sequence\n            intents.push({\n                representation: [game.word(\"DEBUG\"), game.word(\"long-ping\")],\n                sequence: [\n                    {\n                        func: \"newLine\",\n                        args: [\"piiiiiiiiing!\"],\n                        pause: 300,\n                        events: [{ type: \"ping\" }],\n                        duration: 2,\n                    },\n                ],\n            });\n            return intents;\n        },\n    });\n    // 3 ticks\n    player.addPattern({\n        intents: function () {\n            var intents = [];\n            // the sequence\n            intents.push({\n                representation: [game.word(\"wait 5 ticks\")],\n                sequence: [createWaitAction(5)],\n            });\n            return intents;\n        },\n    });\n    // tick timers up\n    game.addHandler(0, {\n        on_tick: function (data) {\n            for (var _i = 0, _a = game.entities.filter(function (e) { return e.timer; }); _i < _a.length; _i++) {\n                var timer = _a[_i];\n                timer.timer.time += 1;\n            }\n        },\n    });\n}\nexports.loadMod = loadMod;\nmodule.exports = { loadMod: loadMod };\n","\"use strict\";\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction makeDevil() {\n    return { name: \"devil\", actor: { intent: null } };\n}\nfunction loadMod(game) {\n    var player = game.entities.filter(function (e) { return e.player; })[0];\n    var area = game.entities.filter(function (e) { return e.area; })[0];\n    game.actions.newLine = function () {\n        var _a;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return (_a = game.newLine).call.apply(_a, __spreadArrays([game], args));\n    };\n    console.log(\"loading mod fight\");\n    var devil = game.addEntity(makeDevil(), area);\n    game.addEntity({ quality: { name: \"Health\", value: 10, pyramid: false } }, devil, \"quality\");\n    game.addEntity({ quality: { name: \"Power\", value: 6, pyramid: false } }, devil, \"quality\");\n    // game.addEntity(\n    //     { quality: { name: \"addPower\", value: 4, pyramid: false } },\n    //     devil,\n    //     \"quality\"\n    // );\n    // game.addEntity(\n    //     { quality: { name: \"mulPower\", value: 4, pyramid: false } },\n    //     devil,\n    //     \"quality\"\n    // );\n    var knife = game.addEntity({ name: \"knife\" }, devil, \"activeItem\");\n    game.addEntity({ quality: { name: \"addPower\", value: 4, pyramid: false } }, knife, \"quality\");\n    // devils with no intent will do a 6-tick dance\n    game.addHandler(5, {\n        name: \"devil AI handler\",\n        on_getIntents: function () {\n            for (var _i = 0, _a = game\n                .intentless()\n                .filter(function (d) { return d.name === \"devil\"; }); _i < _a.length; _i++) {\n                var devil_1 = _a[_i];\n                console.log(\"setting intent for devil\");\n                if (Math.random() < 1) {\n                    // get target\n                    var target = game.entities.filter(function (p) { return p.player; })[0];\n                    // get damage\n                    var damage = game.getTotalQuality(devil_1.id, \"Power\");\n                    // strike\n                    devil_1.actor.intent = {\n                        sequence: [\n                            {\n                                duration: 5,\n                                processText: \"The devil is preparing to strike...\",\n                            },\n                            {\n                                func: \"newLine\",\n                                args: [\n                                    \"The devil \",\n                                    { text: \"strikes\", foreground: \"orange\" },\n                                    \" at you for \",\n                                    {\n                                        text: damage + \" damage\",\n                                        // foreground: \"\",\n                                        background: \"gray\",\n                                    },\n                                    \"!\",\n                                ],\n                                events: [\n                                    {\n                                        type: \"AttackBegin\",\n                                        from: devil_1,\n                                        to: target,\n                                        damage: damage,\n                                    },\n                                ],\n                            },\n                        ],\n                    };\n                }\n                else {\n                    // dodge\n                    devil_1.actor.intent = {\n                        sequence: [\n                            {\n                                func: \"newLine\",\n                                args: [\"The devil dodges.\"],\n                            },\n                            {\n                                duration: 6,\n                                processText: \"The devil is dodging...\",\n                            },\n                        ],\n                    };\n                }\n            }\n        },\n    });\n    game.addHandler(0, {\n        name: \"get hit handler\",\n        on_AttackBegin: function (event) {\n            console.log(\"Ouch.\");\n            game\n                .getChildren(event.to)\n                .filter(function (q) { return q.quality && q.quality.name === \"Health\"; })[0].quality.value -= event.damage;\n            game.newLine(\"You take \" + event.damage + \" damage!\");\n        },\n    });\n}\nexports.loadMod = loadMod;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ticks per second\nexports.tps = 6;\n// milliseconds per tick\nexports.mpt = 300;\nfunction s(nr) {\n    return exports.tps * nr;\n}\nexports.s = s;\nfunction m(nr) {\n    return exports.tps * nr * 60;\n}\nexports.m = m;\nfunction h(nr) {\n    return exports.tps * nr * 3600;\n}\nexports.h = h;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar GameModule = require(\"./GameModule\");\nvar PlayerModule = require(\"./PlayerModule\");\nvar debugMod = require(\"./modDebug\");\nvar fightingMod = require(\"./modFighting\");\n// HACK\n// let newLine = utils.newLine;\n// import { newLine } from \"./utils\";\nvar game = new GameModule.Game();\nvar player = new PlayerModule.Player();\ngame.player = player;\n// load mods\nvar debug = false;\nvar areaA = game.addEntity({\n    name: \"room A\",\n    area: true,\n});\nvar areaB = game.addEntity({\n    name: \"room B\",\n    area: true,\n});\nvar areaC = game.addEntity({\n    name: \"room C\",\n    area: true,\n});\ngame.addEntity({\n    path: {\n        from: areaA.id,\n        to: areaB.id,\n        distance: 10,\n    },\n});\ngame.addEntity({\n    path: {\n        from: areaB.id,\n        to: areaC.id,\n        distance: 20,\n    },\n});\ngame.addEntity({\n    path: {\n        from: areaC.id,\n        to: areaB.id,\n        distance: 4,\n    },\n});\ngame.addEntity(player, areaA);\ngame.addEntity({ quality: { name: \"Health\", value: 10, pyramid: false } }, player, \"quality\");\n// teaRoomMod.loadMod(game);\ndebugMod.loadMod(game);\nfightingMod.loadMod(game);\nconsole.log(game.entities);\nvar keys = \"abcdefghijklmnopqrstuwxyz\".split(\"\");\ndocument.addEventListener(\"keypress\", function (event) {\n    var name = event.key;\n    if (name === \"`\") {\n        game.playRandomly = !game.playRandomly;\n    }\n    if (player.picking && keys.indexOf(name) !== -1) {\n        // alert(`pressed ${keys.indexOf(name)} of ${keys}`)\n        player.pickNextWord(keys.indexOf(name));\n        player.setOptionsUI();\n    }\n}, false);\nplayer.updateCommandUI();\ngame.updateEntityTreeUI();\ngame.getPlayerIntent();\nconsole.log({ \"all intents\": player.getAllIntents() });\n// for (let intent of player.getAllIntents()) {\n//     console.log({ intent })\n// }\nconsole.log(game.handlers);\nfunction debugText(text) {\n    document.getElementById(\"debug\").innerText = text;\n}\n"],"names":[],"sourceRoot":""}